<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Find the minimum cost to reach destination using a train</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="find-the-minimum-cost-to-reach-destination-using-a-train" class="section level1">
<h1>Find the minimum cost to reach destination using a train</h1>
<p>There are N stations on route of a train. The train goes from station 0 to N-1. The ticket cost for all pair of stations (i, j) is given where j is greater than i. Find the minimum cost to reach the destination.<span id="more-134335"></span></p>
<p>Consider the following example:</p>
<pre><code> 
Input: 
cost[N][N] = { {0, 15, 80, 90},
              {INF, 0, 40, 50},
              {INF, INF, 0, 70},
              {INF, INF, INF, 0}
             };
There are 4 stations and cost[i][j] indicates cost to reach j 
from i. The entries where j 
We strongly recommend to minimize your browser and try this yourself first.
The minimum cost to reach N-1 from 0 can be recursively written as following:
 
minCost(0, N-1) = MIN { cost[0][n-1],  
                        cost[0][1] + minCost(1, N-1),  
                        minCost(0, 2) + minCost(2, N-1), 
                        ........, 
                        minCost(0, N-2) + cost[N-2][n-1] }  </code></pre>
<p>The following is C++ implementation of above recursive formula.</p>
<pre><code> 
// A naive recursive solution to find min cost path from station 0
// to station N-1
#include&lt;iostream&gt;
#include&lt;climits&gt;
using namespace std;

// infinite value
#define INF INT_MAX

// Number of stations
#define N 4

// A recursive function to find the shortest path from
// source &#39;s&#39; to destination &#39;d&#39;.
int minCostRec(int cost[][N], int s, int d)
{
    // If source is same as destination
    // or destination is next to source
    if (s == d || s+1 == d)
      return cost[s][d];

    // Initialize min cost as direct ticket from
    // source &#39;s&#39; to destination &#39;d&#39;.
    int min = cost[s][d];

    // Try every intermediate vertex to find minimum
    for (int i = s+1; i&lt;d; i++)
    {
        int c = minCostRec(cost, s, i) +
                minCostRec(cost, i, d);
        if (c &lt; min)
           min = c;
    }
    return min;
}

// This function returns the smallest possible cost to
// reach station N-1 from station 0. This function mainly
// uses minCostRec().
int minCost(int cost[][N])
{
    return minCostRec(cost, 0, N-1);
}

// Driver program to test above function
int main()
{
    int cost[N][N] = { {0, 15, 80, 90},
                      {INF, 0, 40, 50},
                      {INF, INF, 0, 70},
                      {INF, INF, INF, 0}
                    };
    cout &lt;&lt; &quot;The Minimum cost to reach station &quot;
          &lt;&lt; N &lt;&lt; &quot; is &quot; &lt;&lt; minCost(cost);
    return 0;
} </code></pre>
<p>Output:</p>
<pre><code> The Minimum cost to reach station 4 is 65 </code></pre>
<p>Time complexity of the above implementation is exponential as it tries every possible path from 0 to N-1. The above solution solves same subrpoblems multiple times (it can be seen by drawing recursion tree for minCostPathRec(0, 5).<br /> Since this problem has both properties of dynamic programming problems ((see <a href="http://www.geeksforgeeks.org/archives/12635">this</a>and <a href="http://www.geeksforgeeks.org/archives/12819">this</a>). Like other typical <a href="http://www.geeksforgeeks.org/archives/tag/dynamic-programming">Dynamic Programming(DP) problems,</a> re-computations of same subproblems can be avoided by storing the solutions to subproblems and solving problems in bottom up manner.</p>
<p>One dynamic programming solution is to create a 2D table and fill the table using above given recursive formula. The extra space required in this solution would be O(N<sup>2</sup>) and time complexity would be O(N<sup>3</sup>)</p>
<p>We can solve this problem using O(N) extra space and O(N<sup>2</sup>) time. The idea is based on the fact that given input matrix is a Directed Acyclic Graph (DAG). The shortest path in DAG can be calculated using the approach discussed in below post.</p>
<p><a href="http://www.geeksforgeeks.org/shortest-path-for-directed-acyclic-graphs/">Shortest Path in Directed Acyclic Graph</a></p>
<p>We need to do less work here compared to above mentioned post as we know <a href="http://www.geeksforgeeks.org/topological-sorting/">topological sorting</a> of the graph. The topological sorting of vertices here is 0, 1, ..., N-1. Following is the idea once topological sorting is known.</p>
<p>The idea in below code is to first calculate min cost for station 1, then for station 2, and so on. These costs are stored in an array dist[0...N-1].</p>
<p>1) The min cost for station 0 is 0, i.e., dist[0] = 0</p>
<p>2) The min cost for station 1 is cost[0][1], i.e., dist[1] = cost[0][1]</p>
<p>3) The min cost for station 2 is minimum of following two.<br />      a) dist[0] + cost[0][2]<br />      b) dist[1] + cost[1][2]</p>
<p>3) The min cost for station 3 is minimum of following three.<br />      a) dist[0] + cost[0][3]<br />      b) dist[1] + cost[1][3]<br />      c) dist[2] + cost[2][3]</p>
<p>Similarly, dist[4], dist[5], ... dist[N-1] are calculated.</p>
<p>Below is C++ implementation of above idea.</p>
<pre><code> 
// A Dynamic Programming based solution to find min cost
// to reach station N-1 from station 0.
#include&lt;iostream&gt;
#include&lt;climits&gt;
using namespace std;

#define INF INT_MAX
#define N 4

// This function returns the smallest possible cost to
// reach station N-1 from station 0.
int minCost(int cost[][N])
{
    // dist[i] stores minimum cost to reach station i
    // from station 0.
    int dist[N];
    for (int i=0; i&lt;N; i++)
       dist[i] = INF;
    dist[0] = 0;

    // Go through every station and check if using it
    // as an intermediate station gives better path
    for (int i=0; i&lt;N; i++)
       for (int j=i+1; j&lt;N; j++)
          if (dist[j] &gt; dist[i] + cost[i][j])
             dist[j] = dist[i] + cost[i][j];

    return dist[N-1];
}

// Driver program to test above function
int main()
{
    int cost[N][N] = { {0, 15, 80, 90},
                      {INF, 0, 40, 50},
                      {INF, INF, 0, 70},
                      {INF, INF, INF, 0}
                    };
    cout &lt;&lt; &quot;The Minimum cost to reach station &quot;
          &lt;&lt; N &lt;&lt; &quot; is &quot; &lt;&lt; minCost(cost);
    return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> The Minimum cost to reach station 4 is 65 </code></pre>
<p>This article is contributed by <strong>Udit Gupta</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<p><br /></p>
<div id="source-57" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/find-the-minimum-cost-to-reach-a-destination-where-every-station-is-connected-in-one-direction/" class="uri">http://www.geeksforgeeks.org/find-the-minimum-cost-to-reach-a-destination-where-every-station-is-connected-in-one-direction/</a></p>
<p><span>Category: <a href="http://www.geeksforgeeks.org/category/graph/">Graph</a></span> <span>Tags: <a href="http://www.geeksforgeeks.org/tag/dynamic-programming/">Dynamic Programming</a></span></p>
<p><br /></p>
<p>Post navigation</p>
<p><span class="nav-previous"><a href="http://www.geeksforgeeks.org/fiberlink-maas360-interview-set-2-written-test-question/"><span class="meta-nav">←</span> Fiberlink (maas360) Interview | Set 2 (Written Test Question)</a></span> <span class="nav-next"><a href="http://www.geeksforgeeks.org/vmware-interview-experience-set-2-on-campus/">VMWare Interview Experience | Set 2 (On-Campus) <span class="meta-nav">→</span></a></span></p>
<p>Writing code in comment? Please use <a href="http://code.geeksforgeeks.org/">code.geeksforgeeks.org</a>, generate link and share the link here.</p>
</div>
</div>
</body>
</html>


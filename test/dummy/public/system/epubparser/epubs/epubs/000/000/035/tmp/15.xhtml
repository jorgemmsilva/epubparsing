<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Length of the longest substring without repeating characters</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="length-of-the-longest-substring-without-repeating-characters" class="section level1">
<h1>Length of the longest substring without repeating characters</h1>
<p>Given a string, find the length of the longest substring without repeating characters. For example, <span id="more-15859"></span>the longest substrings without repeating characters for “ABDEFGABEF” are “BDEFGA” and “DEFGAB”, with length 6. For “BBBB” the longest substring is “B”, with length 1. For “GEEKSFORGEEKS”, there are two longest substrings shown in the below diagrams, with length 7.</p>
<p><a href="http://d2hc1qfcrygj4j.cloudfront.net//wp-content/uploads/unique_char_substr.png"><img src="media/file4.png" title="unique_char_substr" /></a><br /> <a href="http://d2hc1qfcrygj4j.cloudfront.net//wp-content/uploads/unique_char_substr2.png"><img src="media/file5.png" title="unique_char_substr2" /></a><br /> <a href="http://d2hc1qfcrygj4j.cloudfront.net//wp-content/uploads/unique_char_substr3.png"><img src="media/file6.png" title="unique_char_substr3" /></a></p>
<p>The desired time complexity is O(n) where n is the length of the string.</p>
<p><strong>Method 1 (Simple)</strong><br /> We can consider all substrings one by one and check for each substring whether it contains all unique characters or not. There will be n*(n+1)/2 substrings. Whether a substirng contains all unique characters or not can be checked in linear time by scanning it from left to right and keeping a map of visited characters. Time complexity of this solution would be O(n^3).</p>
<p><strong>Method 2 (Linear Time)</strong><br /> Let us talk about the linear time solution now. This solution uses extra space to store the last indexes of already visited characters. The idea is to scan the string from left to right, keep track of the maximum length Non-Repeating Character Substring (NRCS) seen so far. Let the maximum length be max_len. When we traverse the string, we also keep track of length of the current NRCS using cur_len variable. For every new character, we look for it in already processed part of the string (A temp array called visited[] is used for this purpose). If it is not present, then we increase the cur_len by 1. If present, then there are two cases:</p>
<p><strong>a)</strong> The previous instance of character is not part of current NRCS (The NRCS which is under process). In this case, we need to simply increase cur_len by 1.<br /> <strong>b)</strong> If the previous instance is part of the current NRCS, then our current NRCS changes. It becomes the substring staring from the next character of previous instance to currently scanned character. We also need to compare cur_len and max_len, before changing current NRCS (or changing cur_len).</p>
<p><strong>Implementation</strong></p>
<pre><code> 
#include&lt;stdlib.h&gt;
#include&lt;stdio.h&gt;
#define NO_OF_CHARS 256

int min(int a, int b);

int longestUniqueSubsttr(char *str)
{
    int n = strlen(str);
    int cur_len = 1;  // To store the lenght of current substring
    int max_len = 1;  // To store the result
    int prev_index;  // To store the previous index
    int i;
    int *visited = (int *)malloc(sizeof(int)*NO_OF_CHARS);

    /* Initialize the visited array as -1, -1 is used to indicate that
       character has not been visited yet. */
    for (i = 0; i &lt; NO_OF_CHARS;  i++)
        visited[i] = -1;

    /* Mark first character as visited by storing the index of first 
       character in visited array. */
    visited[str[0]] = 0;

    /* Start from the second character. First character is already processed
       (cur_len and max_len are initialized as 1, and visited[str[0]] is set */
    for (i = 1; i &lt; n; i++)
    {
        prev_index =  visited[str[i]];

        /* If the currentt character is not present in the already processed
           substring or it is not part of the current NRCS, then do cur_len++ */
        if (prev_index == -1 || i - cur_len &gt; prev_index)
            cur_len++;

        /* If the current character is present in currently considered NRCS,
           then update NRCS to start from the next character of previous instance. */
        else
        {
            /* Also, when we are changing the NRCS, we should also check whether 
              length of the previous NRCS was greater than max_len or not.*/
            if (cur_len &gt; max_len)
                max_len = cur_len;

            cur_len = i - prev_index;
        }

        visited[str[i]] = i; // update the index of current character
    }

    // Compare the length of last NRCS with max_len and update max_len if needed
    if (cur_len &gt; max_len)
        max_len = cur_len;


    free(visited); // free memory allocated for visited

    return max_len;
}

/* A utility function to get the minimum of two integers */
int min(int a, int b)
{
    return (a&gt;b)?b:a;
}

/* Driver program to test above function */
int main()
{
    char str[] = &quot;ABDEFGABEF&quot;;
    printf(&quot;The input string is %s \n&quot;, str);
    int len =  longestUniqueSubsttr(str);
    printf(&quot;The length of the longest non-repeating character substring is %d&quot;, len);

    getchar();
    return 0;
}
 </code></pre>
<p><strong>Output</strong></p>
<pre><code> 
  The input string is ABDEFGABEF
  The length of the longest non-repeating character substring is 6
 </code></pre>
<p><strong>Time Complexity:</strong> O(n + d) where n is length of the input string and d is number of characters in input string alphabet. For example, if string consists of lowercase English characters then value of d is 26.<br /> <strong>Auxiliary Space:</strong> O(d)<br /> <strong>Algorithmic Paradigm:</strong> Dynamic Programming</p>
<p>As an exercise, try the modified version of the above problem where you need to print the maximum length NRCS also (the above program only prints length of it).</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<p><br /></p>
<div id="source-10" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/length-of-the-longest-substring-without-repeating-characters/" class="uri">http://www.geeksforgeeks.org/length-of-the-longest-substring-without-repeating-characters/</a></p>
</div>
</div>
</body>
</html>


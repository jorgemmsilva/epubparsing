<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Count possible ways to construct buildings</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="count-possible-ways-to-construct-buildings" class="section level1">
<h1>Count possible ways to construct buildings</h1>
<p>Given an input number of sections and each section has 2 plots on either sides of the road. Find all possible ways to construct buildings in the plots such that there is a space between any 2 buildings.<span id="more-134734"></span></p>
<p>Example:</p>
<pre><code> 
N = 1
Output = 4
Place a building on one side.
Place a building on other side
Do not place any building.
Place a building on both sides.

N = 3 
Output = 25
3 sections, which means possible ways for one side are 
BSS, BSB, SSS, SBS, SSB where B represents a building 
and S represents an empty space
Total possible ways are 25, because a way to place on 
one side can correspond to any of 5 ways on other side.

N = 4 
Output = 64
 </code></pre>
<p><strong>We strongly recommend to minimize your browser and try this yourself first</strong></p>
<p>We can simplify the problem to first calculate for one side only. If we know the result for one side, we can always do square of the result and get result for two sides.</p>
<p>A new building can be placed on a section if section just before it has space. A space can be placed anywhere (it doesn’t matter whether the previous section has a building or not).</p>
<pre><code> 
Let countB(i) be count of possible ways with i sections
              ending with a building.
    countS(i) be count of possible ways with i sections
              ending with a space.

// A space can be added after a building or after a space.
countS(N) = countB(N-1) + countS(N-1)

// A building can only be added after a space.
countB[N] = countS(N-1)

// Result for one side is sum of the above two counts.
result1(N) = countS(N) + countB(N)

// Result for two sides is square of result1(N)
result2(N) = result1(N) * result1(N)  </code></pre>
<p>Below is C++ implementation of above idea.</p>
<pre><code> 
// C++ program to count all possible way to construct buildings
#include&lt;iostream&gt;
using namespace std;

// Returns count of possible ways for N sections
int countWays(int N)
{
    // Base case
    if (N == 1)
        return 4;  // 2 for one side and 4 for two sides

    // countB is count of ways with a building at the end
    // countS is count of ways with a space at the end
    // prev_countB and prev_countS are previous values of
    // countB and countS respectively.

    // Initialize countB and countS for one side
    int countB=1, countS=1, prev_countB, prev_countS;

    // Use the above recursive formula for calculating
    // countB and countS using previous values
    for (int i=2; i&lt;=N; i++)
    {
        prev_countB = countB;
        prev_countS = countS;

        countS = prev_countB + prev_countS;
        countB = prev_countS;
    }

    // Result for one side is sum of ways ending with building
    // and ending with space
    int result = countS + countB;

    // Result for 2 sides is square of result for one side
    return (result*result);
}

// Driver program
int main()
{
    int N = 3;
    cout &lt;&lt; &quot;Count of ways for &quot; &lt;&lt; N
         &lt;&lt; &quot; sections is &quot; &lt;&lt; countWays(N);
    return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> 25 </code></pre>
<p>Time complexity: O(N)</p>
<p>Auxiliary Space: O(1)</p>
<p>Algorithmic Paradigm: Dynamic Programming</p>
<p><strong>Optimized Solution:</strong><br /> Note that the above solution can be further optimized. If we take closer look at the results, for different values, we can notice that the results for two sides are squares of <a href="http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/">Fibonacci Numbers</a>.</p>
<p>N = 1, result = 4 [result for one side = 2]<br /> N = 2, result = 9 [result for one side = 3]<br /> N = 3, result = 25 [result for one side = 5]<br /> N = 4, result = 64 [result for one side = 8]<br /> N = 5, result = 169 [result for one side = 13]<br /> …………………….<br /> …………………….</p>
<p>In general, we can say</p>
<pre><code> 
  result(N) = fib(N+2)2
  
  fib(N) is a function that returns N&#39;th 
         Fibonacci Number. 
    </code></pre>
<p>Therefore, we can use <a href="http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/">O(LogN) implementation of Fibonacci Numbers</a> to find number of ways in O(logN) time.</p>
<p>This article is contributed by <strong>GOPINATH</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<p><br /></p>
<div id="source-60" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/count-possible-ways-to-construct-buildings/" class="uri">http://www.geeksforgeeks.org/count-possible-ways-to-construct-buildings/</a></p>
</div>
</div>
</body>
</html>


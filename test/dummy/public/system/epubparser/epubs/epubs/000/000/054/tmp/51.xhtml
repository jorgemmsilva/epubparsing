<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Count number of binary strings without consecutive 1's</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="count-number-of-binary-strings-without-consecutive-1s" class="section level1">
<h1>Count number of binary strings without consecutive 1's</h1>
<p>Given a positive integer N, count all possible distinct binary strings of length N such that there are no consecutive 1’s.<span id="more-129801"></span></p>
<p>Examples:</p>
<pre><code> 
Input:  N = 2
Output: 3
// The 3 strings are 00, 01, 10

Input: N = 3
Output: 5
// The 5 strings are 000, 001, 010, 100, 101 </code></pre>
<p>This problem can be solved using Dynamic Programming. Let a[i] be the number of binary strings of length i which do not contain any two consecutive 1’s and which end in 0. Similarly, let b[i] be the number of such strings which end in 1. We can append either 0 or 1 to a string ending in 0, but we can only append 0 to a string ending in 1. This yields the recurrence relation:</p>
<pre><code> 
a[i] = a[i - 1] + b[i - 1]
b[i] = a[i - 1]  </code></pre>
<p>The base cases of above recurrence are a[1] = b[1] = 1. The total number of strings of length i is just a[i] + b[i].</p>
<p>Following is C++ implementation of above solution. In the following implementation, indexes start from 0. So a[i] represents the number of binary strings for input length i+1. Similarly, b[i] represents binary strings for input length i+1.</p>
<pre><code> 
// C++ program to count all distinct binary strings
// without two consecutive 1&#39;s
#include &lt;iostream&gt;
using namespace std;

int countStrings(int n)
{
    int a[n], b[n];
    a[0] = b[0] = 1;
    for (int i = 1; i &lt; n; i++)
    {
        a[i] = a[i-1] + b[i-1];
        b[i] = a[i-1];
    }
    return a[n-1] + b[n-1];
}


// Driver program to test above functions
int main()
{
    cout &lt;&lt; countStrings(3) &lt;&lt; endl;
    return 0;
}    </code></pre>
<p>Output:</p>
<pre><code> 5 </code></pre>
<p><strong>Source:</strong><br /> <a href="http://courses.csail.mit.edu/6.006/oldquizzes/solutions/q2-f2009-sol.pdf">courses.csail.mit.edu/6.006/oldquizzes/solutions/q2-f2009-sol.pdf</a></p>
<p>This article is contributed by <strong>Rahul Jain</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<p><br /></p>
<div id="source-47" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/" class="uri">http://www.geeksforgeeks.org/count-number-binary-strings-without-consecutive-1s/</a></p>
<p><span>Category: <a href="http://www.geeksforgeeks.org/category/c-arrays/">Arrays</a></span> <span>Tags: <a href="http://www.geeksforgeeks.org/tag/dynamic-programming/">Dynamic Programming</a></span></p>
</div>
</div>
</body>
</html>


<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Count all possible paths from top left to bottom right of a mXn matrix</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="count-all-possible-paths-from-top-left-to-bottom-right-of-a-mxn-matrix" class="section level1">
<h1>Count all possible paths from top left to bottom right of a mXn matrix</h1>
<p>The problem is to count all the possible paths from top left to bottom right of a mXn matrix with the constraints that <em><strong>from each cell you can either move only to right or down</strong></em><span id="more-125069"></span></p>
<p>We have discussed a <a href="http://www.geeksforgeeks.org/print-all-possible-paths-from-top-left-to-bottom-right-of-a-mxn-matrix/">solution to print all possible paths</a>, counting all paths is easier. Let NumberOfPaths(m, n) be the count of paths to reach row number m and column number n in the matrix, NumberOfPaths(m, n) can be recursively written as following.</p>
<pre><code> 
#include &lt;iostream&gt;
using namespace std;

// Returns count of possible paths to reach cell at row number m and column
// number n from the topmost leftmost cell (cell at 1, 1)
int  numberOfPaths(int m, int n)
{
   // If either given row number is first or given column number is first
   if (m == 1 || n == 1)
        return 1;

   // If diagonal movements are allowed then the last addition
   // is required.
   return  numberOfPaths(m-1, n) + numberOfPaths(m, n-1); 
           // + numberOfPaths(m-1,n-1);
}

int main()
{
    cout &lt;&lt; numberOfPaths(3, 3);
    return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> 6 </code></pre>
<p>The time complexity of above recursive solution is exponential. There are many overlapping subproblems. We can draw a recursion tree for numberOfPaths(3, 3) and see many overlapping subproblems. The recursion tree would be similar to <a href="http://www.geeksforgeeks.org/dynamic-programming-set-4-longest-common-subsequence/">Recursion tree for Longest Common Subsequence problem</a>.<br /> So this problem has both properties (see <a href="http://www.geeksforgeeks.org/dynamic-programming-set-1/">this </a>and <a href="http://www.geeksforgeeks.org/dynamic-programming-set-2-optimal-substructure-property/">this</a>) of a dynamic programming problem. Like other typical <a href="http://www.geeksforgeeks.org/archives/tag/dynamic-programming">Dynamic Programming(DP) problems</a>, recomputations of same subproblems can be avoided by constructing a temporary array count[][] in bottom up manner using the above recursive formula.</p>
<pre><code> 
#include &lt;iostream&gt;
using namespace std;

// Returns count of possible paths to reach cell at row number m and column
// number n from the topmost leftmost cell (cell at 1, 1)
int numberOfPaths(int m, int n)
{
    // Create a 2D table to store results of subproblems
    int count[m][n];

    // Count of paths to reach any cell in first column is 1
    for (int i = 0; i &lt; m; i++)
        count[i][0] = 1;

    // Count of paths to reach any cell in first column is 1
    for (int j = 0; j &lt; n; j++)
        count[0][j] = 1;

    // Calculate count of paths for other cells in bottom-up manner using
    // the recursive solution
    for (int i = 1; i &lt; m; i++)
    {
        for (int j = 1; j &lt; n; j++)

            // By uncommenting the last part the code calculatest he total
            // possible paths if the diagonal Movements are allowed
            count[i][j] = count[i-1][j] + count[i][j-1]; //+ count[i-1][j-1];

    }
    return count[m-1][n-1];
}

// Driver program to test above functions
int main()
{
    cout &lt;&lt; numberOfPaths(3, 3);
    return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> 6 </code></pre>
<p>Time complexity of the above dynamic programming solution is O(mn).</p>
<p>Note the count can also be calculated using the formula (m-1 + n-1)!/(m-1)!(n-1)! as mentioned in the comments of <a href="http://www.geeksforgeeks.org/print-all-possible-paths-from-top-left-to-bottom-right-of-a-mxn-matrix/">this</a>article.</p>
<p>This article is contributed by <strong>Hariprasad NG</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<p><br /></p>
<div id="source-44" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/count-possible-paths-top-left-bottom-right-nxm-matrix/" class="uri">http://www.geeksforgeeks.org/count-possible-paths-top-left-bottom-right-nxm-matrix/</a></p>
<p><span>Category: <a href="http://www.geeksforgeeks.org/category/c-arrays/">Arrays</a></span> <span>Tags: <a href="http://www.geeksforgeeks.org/tag/dynamic-programming/">Dynamic Programming</a></span></p>
</div>
</div>
</body>
</html>


<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Dynamic Programming | Set 33 (Find if a string is interleaved of two other strings)</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="dynamic-programming-set-33-find-if-a-string-is-interleaved-of-two-other-strings" class="section level1">
<h1>Dynamic Programming | Set 33 (Find if a string is interleaved of two other strings)</h1>
<p>Given three strings A, B and C. Write a function that checks whether C is an interleaving of A and B. <span id="more-119634"></span> C is said to be interleaving A and B, if it contains all characters of A and B and order of all characters in individual strings is preserved.</p>
<p>We have discussed a simple solution of this problem <a href="http://www.geeksforgeeks.org/check-whether-a-given-string-is-an-interleaving-of-two-other-given-strings/">here</a>. The simple solution doesn’t work if strings A and B have some common characters. For example A = “XXY”, string B = “XXZ” and string C = “XXZXXXY”. To handle all cases, two possibilities need to be considered.</p>
<p><strong>a)</strong> If first character of C matches with first character of A, we move one character ahead in A and C and recursively check.</p>
<p><strong>b)</strong> If first character of C matches with first character of B, we move one character ahead in B and C and recursively check.</p>
<p>If any of the above two cases is true, we return true, else false. Following is simple recursive implementation of this approach (Thanks to <a href="http://www.geeksforgeeks.org/check-whether-a-given-string-is-an-interleaving-of-two-other-given-strings/#comment-7542">Frederic</a>for suggesting this)</p>
<pre><code> 
// A simple recursive function to check whether C is an interleaving of A and B
bool isInterleaved(char *A, char *B, char *C)
{
    // Base Case: If all strings are empty
    if (!(*A || *B || *C))
        return true;

    // If C is empty and any of the two strings is not empty
    if (*C == &#39;\0&#39;)
        return false;

    // If any of the above mentioned two possibilities is true,
    // then return true, otherwise false
    return ( (*C == *A) &amp;&amp; isInterleaved(A+1, B, C+1))
           || ((*C == *B) &amp;&amp; isInterleaved(A, B+1, C+1));
}
 </code></pre>
<p><strong>Dynamic Programming</strong><br /> The worst case time complexity of recursive solution is O(2<sup>n</sup>). The above recursive solution certainly has many overlapping subproblems. For example, if wee consider A = “XXX”, B = “XXX” and C = “XXXXXX” and draw recursion tree, there will be many overlapping subproblems.<br /> Therefore, like other typical <a href="http://www.geeksforgeeks.org/tag/dynamic-programming/">Dynamic Programming problems</a>, we can solve it by creating a table and store results of subproblems in bottom up manner. Thanks to <a href="https://plus.google.com/104230157879525004164/posts">Abhinav Ramana</a> for suggesting this method and implementation.</p>
<pre><code> 
// A Dynamic Programming based program to check whether a string C is
// an interleaving of two other strings A and B.
#include &lt;iostream&gt;
#include &lt;string.h&gt;
using namespace std;

// The main function that returns true if C is
// an interleaving of A and B, otherwise false.
bool isInterleaved(char* A, char* B, char* C)
{
    // Find lengths of the two strings
    int M = strlen(A), N = strlen(B);

    // Let us create a 2D table to store solutions of
    // subproblems.  C[i][j] will be true if C[0..i+j-1]
    // is an interleaving of A[0..i-1] and B[0..j-1].
    bool IL[M+1][N+1];

    memset(IL, 0, sizeof(IL)); // Initialize all values as false.

    // C can be an interleaving of A and B only of sum
    // of lengths of A &amp; B is equal to length of C.
    if ((M+N) != strlen(C))
       return false;

    // Process all characters of A and B
    for (int i=0; i&lt;=M; ++i)
    {
        for (int j=0; j&lt;=N; ++j)
        {
            // two empty strings have an empty string
            // as interleaving
            if (i==0 &amp;&amp; j==0)
                IL[i][j] = true;

            // A is empty
            else if (i==0 &amp;&amp; B[j-1]==C[j-1])
                IL[i][j] = IL[i][j-1];

            // B is empty
            else if (j==0 &amp;&amp; A[i-1]==C[i-1])
                IL[i][j] = IL[i-1][j];

            // Current character of C matches with current character of A,
            // but doesn&#39;t match with current character of B
            else if(A[i-1]==C[i+j-1] &amp;&amp; B[j-1]!=C[i+j-1])
                IL[i][j] = IL[i-1][j];

            // Current character of C matches with current character of B,
            // but doesn&#39;t match with current character of A
            else if (A[i-1]!=C[i+j-1] &amp;&amp; B[j-1]==C[i+j-1])
                IL[i][j] = IL[i][j-1];

            // Current character of C matches with that of both A and B
            else if (A[i-1]==C[i+j-1] &amp;&amp; B[j-1]==C[i+j-1])
                IL[i][j]=(IL[i-1][j] || IL[i][j-1]) ;
        }
    }

    return IL[M][N];
}

// A function to run test cases
void test(char *A, char *B, char *C)
{
    if (isInterleaved(A, B, C))
        cout &lt;&lt; C &lt;&lt;&quot; is interleaved of &quot; &lt;&lt; A &lt;&lt;&quot; and &quot; &lt;&lt; B &lt;&lt; endl;
    else
        cout &lt;&lt; C &lt;&lt;&quot; is not interleaved of &quot; &lt;&lt; A &lt;&lt;&quot; and &quot; &lt;&lt; B &lt;&lt; endl;
}


// Driver program to test above functions
int main()
{
    test(&quot;XXY&quot;, &quot;XXZ&quot;, &quot;XXZXXXY&quot;);
    test(&quot;XY&quot; ,&quot;WZ&quot; ,&quot;WZXY&quot;);
    test (&quot;XY&quot;, &quot;X&quot;, &quot;XXY&quot;);
    test (&quot;YX&quot;, &quot;X&quot;, &quot;XXY&quot;);
    test (&quot;XXY&quot;, &quot;XXZ&quot;, &quot;XXXXZY&quot;);
    return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> XXZXXXY is not interleaved of XXY and XXZ
WZXY is interleaved of XY and WZ
XXY is interleaved of XY and X
XXY is not interleaved of YX and X
XXXXZY is interleaved of XXY and XXZ </code></pre>
<p>See <a href="http://ideone.com/4jnFZu">this</a>for more test cases.</p>
<p>Time Complexity: O(MN)<br /> Auxiliary Space: O(MN)</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<p><br /></p>
<div id="source-39" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/check-whether-a-given-string-is-an-interleaving-of-two-other-given-strings-set-2/" class="uri">http://www.geeksforgeeks.org/check-whether-a-given-string-is-an-interleaving-of-two-other-given-strings-set-2/</a></p>
<p><span>Category: <a href="http://www.geeksforgeeks.org/category/c-strings/">Strings</a></span> <span>Tags: <a href="http://www.geeksforgeeks.org/tag/dynamic-programming/">Dynamic Programming</a></span></p>
<p><br /></p>
<p>Post navigation</p>
<p><span class="nav-previous"><a href="http://www.geeksforgeeks.org/find-the-point-where-a-function-becomes-negative/"><span class="meta-nav">←</span> Unbounded Binary Search Example (Find the point where a monotonically increasing function becomes positive first time)</a></span> <span class="nav-next"><a href="http://www.geeksforgeeks.org/check-for-identical-bsts-without-building-the-trees/">Check for Identical BSTs without building the trees <span class="meta-nav">→</span></a></span></p>
<p>Writing code in comment? Please use <a href="http://code.geeksforgeeks.org/">code.geeksforgeeks.org</a>, generate link and share the link here.</p>
</div>
</div>
</body>
</html>


<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Minimum number of squares whose sum equals to given number n</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="minimum-number-of-squares-whose-sum-equals-to-given-number-n" class="section level1">
<h1>Minimum number of squares whose sum equals to given number n</h1>
<p>A number can always be represented as a sum of squares of other numbers. Note that 1 is a square and we can always break a number as (1*1 + 1*1 + 1*1 + â€¦). Given a number n, find the minimum number of squares that sum to X.<span id="more-135219"></span></p>
<p>Examples:</p>
<pre><code> 
Input:  n = 100
Output: 1
100 can be written as 102. Note that 100 can also be 
written as 52 + 52 + 52 + 52, but this
representation requires 4 squares.

Input:  n = 6
Output: 3
 </code></pre>
<p><strong>We strongly recommend you to minimize your browser and try this yourself first.</strong><br /> The idea is simple, we start from 1 and go till a number whose square is smaller than or equals to n. For every number x, we recur for n-x. Below is the recursive formula.</p>
<pre><code> 
If n = 1 and x*x 
Below is a simple recursive solution based on above recursive formula.
 
// A naive recursive C++ program to find minimum
// number of squares whose sum is equal to a given number
#include&lt;bits/stdc++.h&gt;
using namespace std;

// Returns count of minimum squares that sum to n
int getMinSquares(unsigned int n)
{
    // base cases
    if (n &lt;= 3)
        return n;

    // getMinSquares rest of the table using recursive
    // formula
    int res = n; // Maximum squares required is n (1*1 + 1*1 + ..)

    // Go through all smaller numbers
    // to recursively find minimum
    for (int x = 1; x &lt;= n; x++)
    {
        int temp = x*x;
        if (temp &gt; n)
            break;
        else
            res =  min(res, 1+getMinSquares(n - temp));
    }
    return res;
}

// Driver program
int main()
{
    cout &lt;&lt; getMinSquares(6);
    return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> 3 </code></pre>
<p>The time complexity of above solution is exponential. If we draw the complete recursion tree, we can observer that many subproblems are solved again and again. For example, when we start from n = 6, we can reach 4 by subtracting one 2 times and by subtracting 2 one times. So the subproblem for 4 is called twice.<br /> Since same suproblems are called again, this problem has Overlapping Subprolems property. So min square sum problem has both properties (see <a href="http://www.geeksforgeeks.org/archives/12635">this</a>and <a href="http://www.geeksforgeeks.org/archives/12819">this</a>) of a dynamic programming problem. Like other typical <a href="http://www.geeksforgeeks.org/archives/tag/dynamic-programming">Dynamic Programming(DP) problems</a>, recomputations of same subproblems can be avoided by constructing a temporary array table[][] in bottom up manner. Below is Dynamic Programming based solution</p>
<pre><code> 
// A dynamic programming based C++ program to find minimum
// number of squares whose sum is equal to a given number
#include&lt;bits/stdc++.h&gt;
using namespace std;

// Returns count of minimum squares that sum to n
int getMinSquares(int n)
{
    // Create a dynamic programming table
    // to store sq
    int *dp = new int[n+1];

    // getMinSquares table for base case entries
    dp[0] = 0;
    dp[1] = 1;
    dp[2] = 2;
    dp[3] = 3;

    // getMinSquares rest of the table using recursive
    // formula
    for (int i = 4; i &lt;= n; i++)
    {
        // max value is i as i can always be represented
        // as 1*1 + 1*1 + ...
        dp[i] = i;

        // Go through all smaller numbers to
        // to recursively find minimum
        for (int x = 1; x &lt;= i; x++) {
            int temp = x*x;
            if (temp &gt; i)
                break;
            else dp[i] = min(dp[i], 1+dp[i-temp]);
        }
    }

    // Store result and free dp[]
    int res = dp[n];
    delete [] dp;

    return res;
}

// Driver program
int main()
{
    cout &lt;&lt; getMinSquares(6);
    return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> 3 </code></pre>
<p>Thanks to Gaurav Ahirwar for suggesting this solution in a comment <a href="http://qa.geeksforgeeks.org/1565/print-minimum-number-squares-whose-sum-equals-given-number?show=1565#q1565">here</a>.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<p><br /></p>
<div id="source-65" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/minimum-number-of-squares-whose-sum-equals-to-given-number-n/" class="uri">http://www.geeksforgeeks.org/minimum-number-of-squares-whose-sum-equals-to-given-number-n/</a></p>
<p><span>Category: <a href="http://www.geeksforgeeks.org/category/c-programs/">Misc</a></span> <span>Tags: <a href="http://www.geeksforgeeks.org/tag/dynamic-programming/">Dynamic Programming</a>, <a href="http://www.geeksforgeeks.org/tag/mathematicalalgo/">MathematicalAlgo</a></span></p>
</div>
</div>
</body>
</html>


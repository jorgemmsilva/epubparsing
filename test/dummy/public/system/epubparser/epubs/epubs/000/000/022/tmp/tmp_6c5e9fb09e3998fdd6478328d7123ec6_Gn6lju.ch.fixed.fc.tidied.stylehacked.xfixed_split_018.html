<?xml version='1.0' encoding='utf-8'?>
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
<meta name="generator" content="HTML Tidy for Linux (vers 7 December 2008), see www.w3.org"/>
<meta http-equiv="CONTENT-TYPE" content="text/html; charset=utf-8"/>

<meta name="GENERATOR" content="OpenOffice.org 3.0 (Unix)"/>
<meta name="CREATED" content="20151109;11564100"/>
<meta name="CHANGED" content="20151129;1342700"/>
<meta name="Info_1" content=""/>
<meta name="Info_2" content=""/>
<meta name="Info_3" content=""/>
<meta name="Info_4" content=""/>
<title>Essential Python</title>
<meta content="http://www.w3.org/1999/xhtml; charset=utf-8" http-equiv="Content-Type"/><link href="stylesheet.css" type="text/css" rel="stylesheet"/><style type="text/css">
		@page { margin-bottom: 5.000000pt; margin-top: 5.000000pt; }</style></head>
<body dir="ltr" class="calibre">
<h1 lang="en-GB" class="western3" id="calibre_pb_17"><a id="Example_Project__252525E2_252525"></a> 19. Example Project –
Software Bug Tracker</h1>
<p lang="en-GB" class="western">Having been through the
essential bits of Python and some of the libraries its time to put
it all together to write a script capable of doing something rather
than just demonstrating code. This chapter shows an example of how
to write a program. The program that is going to be written is a
bug tracker for helping you keep track of issues within your
projects. To do this it will allow issues to be created and
assigned to a project the issues will then be able to be edited and
their status updated.</p>
<h2 lang="en-GB" class="western4">Issue Class</h2>
<p lang="en-GB" class="western">The first thing to do is to
define what the issue class the following types of issue are going
to be defined</p>
<p lang="en-GB" class="list-indent-western">Bug – A bug found
within existing code</p>
<p lang="en-GB" class="list-indent-western">New Feature – A new
feature for the next release</p>
<p lang="en-GB" class="list-indent-western">Improvement – A change
to the existing code to improve it</p>
<p lang="en-GB" class="list-indent-western">Task – Anything not
covered by the other types.</p>
<p lang="en-GB" class="western">Each issue will have a status
associated with it so work on the issues can be checked.</p>
<p lang="en-GB" class="list-indent-western">Open – The issue hasn't
been looked at</p>
<p lang="en-GB" class="list-indent-western">Resolved – The issue
has been fixed but not be closed.</p>
<p lang="en-GB" class="list-indent-western">Closed – The issue is
closed</p>
<p lang="en-GB" class="western">Each issue will also have the
following fields the date the issue was entered, title of the issue
and a description of the issue.</p>
<p lang="en-GB" class="western">Its fairly obvious that a class
can be used to hold an issue, the constructor for the class as
detailed above would look like the following.</p>
<p lang="en-GB" class="c5"><span class="c6">numberIssues =
0</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6"># Definitions for type
of issue</span></p>
<p lang="en-GB" class="c5"><span class="c6">BUG = 0</span></p>
<p lang="en-GB" class="c5"><span class="c6">NEW_FEATURE =
1</span></p>
<p lang="en-GB" class="c5"><span class="c6">IMPROVEMENT =
2</span></p>
<p lang="en-GB" class="c5"><span class="c6">TASK = 3</span></p>
<p lang="en-GB" class="c5"><span class="c6">UNDEFINED =
4</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6"># Definitions for
state</span></p>
<p lang="en-GB" class="c5"><span class="c6">OPEN = 0</span></p>
<p lang="en-GB" class="c5"><span class="c6">RESOLVED =
1</span></p>
<p lang="en-GB" class="c5"><span class="c6">CLOSED = 2</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">#
constructor</span></p>
<p lang="en-GB" class="c5"><span class="c6">def __init__(self,
issuestype, title, details):</span></p>
<p lang="en-GB" class="c5"><span class="c6">if issuestype &lt;=
Issue.UNDEFINED:</span></p>
<p lang="en-GB" class="c5"><span class="c6">self._type =
issuestype</span></p>
<p lang="en-GB" class="c5"><span class="c6">else:</span></p>
<p lang="en-GB" class="c5"><span class="c6">self._type =
Issue.UNDEFINED</span></p>
<p lang="en-GB" class="c5"><span class="c6">self._title =
title</span></p>
<p lang="en-GB" class="c5"><span class="c6">self._details =
details</span></p>
<p lang="en-GB" class="c5"><span class="c6">self._date =
time.localtime(time.time())</span></p>
<p lang="en-GB" class="c5"><span class="c6">self._state =
Issue.OPEN</span></p>
<p lang="en-GB" class="c5"><span class="c6">Issue.numberIssues +=
1</span></p>
<p lang="en-GB" class="western">The constructor allows some of
the arguments to be passed in, <b class="calibre2">issuestype</b> is then checked to
make sure its value is valid. The other arguments are assigned to
the appropriate instance variable, the date variable is set to the
current local time and the state is set to OPEN. Finally the class
variable for the number of issues is incremented.</p>
<p lang="en-GB" class="western">Note that some constant
variables have also been defined to help make the code more
readable.</p>
<p lang="en-GB" class="western">The next thing to do is to
overload the print statement.</p>
<p lang="en-GB" class="c5"><span class="c6"># Dictionary for
type</span></p>
<p lang="en-GB" class="c5"><span class="c6">typeDict = {BUG:
"Bug", NEW_FEATURE: "New Feature", IMPROVEMENT: "Improvement",
TASK: "Task", UNDEFINED: "Undefined"}</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6"># Dictionary for
state</span></p>
<p lang="en-GB" class="c5"><span class="c6">stateDict = {OPEN:
"Open", RESOLVED: "Resolved", CLOSED: "Closed"}</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6"># overload
print()</span></p>
<p lang="en-GB" class="c5"><span class="c6">def
__str__(self):</span></p>
<p lang="en-GB" class="c5"><span class="c6">template = "{0}
{1}\nType:{2} State:{3}\n{4} \n"</span></p>
<p lang="en-GB" class="c5"><span class="c6">datestr =
time.strftime("%d/%m/%y", self._date)</span></p>
<p lang="en-GB" class="c5"><span class="c6">return
template.format(self._title, datestr, Issue.typeDict[self._type],
Issue.stateDict[self._state], self._details)</span></p>
<p lang="en-GB" class="western">Two dictionaries have been
created these are used to get strings for the state and issue types
to display on the screen. A template is then defined which will be
used to create a formatted string and a date string holding the
ASCII version of the date.</p>
<p lang="en-GB" class="western">The following static methods are
defined so that other modules can use the conversion dictionaries
for type and state.</p>
<p lang="en-GB" class="c5"><span class="c6">@staticmethod</span></p>
<p lang="en-GB" class="c5"><span class="c6">def
get_type_str(key):</span></p>
<p lang="en-GB" class="c5"><span class="c6">if key &lt;
len(Issue.typeDict):</span></p>
<p lang="en-GB" class="c5"><span class="c6">return
Issue.typeDict[key]</span></p>
<p lang="en-GB" class="c5"><span class="c6">else:</span></p>
<p lang="en-GB" class="c5"><span class="c6">return ''</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">@staticmethod</span></p>
<p lang="en-GB" class="c5"><span class="c6">def
get_number_types():</span></p>
<p lang="en-GB" class="c5"><span class="c6">return
len(Issue.typeDict)</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">@staticmethod</span></p>
<p lang="en-GB" class="c5"><span class="c6">def
get_state_str(key):</span></p>
<p lang="en-GB" class="c5"><span class="c6">if key &lt;
len(Issue.stateDict):</span></p>
<p lang="en-GB" class="c5"><span class="c6">return
Issue.stateDict[key]</span></p>
<p lang="en-GB" class="c5"><span class="c6">else:</span></p>
<p lang="en-GB" class="c5"><span class="c6">return ''</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">@staticmethod</span></p>
<p lang="en-GB" class="c5"><span class="c6">def
get_number_states():</span></p>
<p lang="en-GB" class="c5"><span class="c6">return
len(Issue.stateDict)</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="western">To make the bug tracker usable
there needs to be a way to search an issue to see if it contains
the specified string which is being searched for. The search method
uses the string <b class="calibre2">find</b> method to check if this search string
is in either the title or the description of the issue, if a match
is found then the method returns true.</p>
<p lang="en-GB" class="c5"><span class="c6">def search(self,
searchstr):</span></p>
<p lang="en-GB" class="c5"><span class="c6">if
self._title.find(searchstr) or
self._details.find(searchstr):</span></p>
<p lang="en-GB" class="c5"><span class="c6">return True</span></p>
<p lang="en-GB" class="c5"><span class="c6">return
False</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="western">The rest of the class consists
of setters and getters for the instance variables.</p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">def set_state(self,
state):</span></p>
<p lang="en-GB" class="c5"><span class="c6">if state &lt;=
Issue.CLOSED:</span></p>
<p lang="en-GB" class="c5"><span class="c6">self._state =
state</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">def set_type(self,
issuestype):</span></p>
<p lang="en-GB" class="c5"><span class="c6">if issuestype &lt;=
Issue.UNDEFINED:</span></p>
<p lang="en-GB" class="c5"><span class="c6">self._type =
issuestype</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">def set_title(self,
title):</span></p>
<p lang="en-GB" class="c5"><span class="c6">self._title =
title</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">def set_details(self,
details):</span></p>
<p lang="en-GB" class="c5"><span class="c6">self._title =
details</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">def
get_details(self):</span></p>
<p lang="en-GB" class="c5"><span class="c6">return
self._details</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">def
get_title(self):</span></p>
<p lang="en-GB" class="c5"><span class="c6">return
self._title</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">def
get_type(self):</span></p>
<p lang="en-GB" class="c5"><span class="c6">return
Issue.typeDict[self._type]</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">def
get_state(self):</span></p>
<p lang="en-GB" class="c5"><span class="c6">return
Issue.stateDict[self._state]</span></p>
<h2 lang="en-GB" class="western4">Project Class</h2>
<p lang="en-GB" class="western">Having defined the Issue class
the next job is to define the Project class, a project needs to
contain its name and the issues associated with it.</p>
<p lang="en-GB" class="c5"><span class="c6">numberProjects =
0</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">#
constructor</span></p>
<p lang="en-GB" class="c5"><span class="c6">def __init__(self,
title='unknown'):</span></p>
<p lang="en-GB" class="c5"><span class="c6">self._title =
title</span></p>
<p lang="en-GB" class="c5"><span class="c6">self._issues =
[]</span></p>
<p lang="en-GB" class="c5"><span class="c6">Project.numberProjects
+= 1</span></p>
<p lang="en-GB" class="western">The constructor above contains
two instant variables the title and an empty list which the issues
will be added into, it also increments the <b class="calibre2">numberProjects</b>
class variable. Note that if a title isn't passed into the
constructor then it will be given the default value “unknown”.</p>
<p lang="en-GB" class="western">The next method to create is one
to overload the <b class="calibre2">print</b> method.</p>
<p lang="en-GB" class="c5"><span class="c6"># overload
print()</span></p>
<p lang="en-GB" class="c5"><span class="c6">def
__str__(self):</span></p>
<p lang="en-GB" class="c5"><span class="c6"># build a list of
issues</span></p>
<p lang="en-GB" class="c5"><span class="c6">issuelist =
''</span></p>
<p lang="en-GB" class="c5"><span class="c6">for (index, i) in
enumerate(self._issues):</span></p>
<p lang="en-GB" class="c5"><span class="c6">issuetemp = '{0:3}.
{1:11} - {2:8} {3}\n'</span></p>
<p lang="en-GB" class="c5"><span class="c6">issuelist +=
issuetemp.format(index, i.get_type(), i.get_state(),
i.get_title())</span></p>
<p lang="en-GB" class="c5"><span class="c6">template = 'Project:
{0} Issues: {1}\n{2}'</span></p>
<p lang="en-GB" class="c5"><span class="c6">return
template.format(self._title, len(self._issues),
issuelist)</span></p>
<p lang="en-GB" class="western">This creates a list of all the
issues in the project and then displays the project name and the
list of issues.</p>
<p lang="en-GB" class="western">The project also needs methods
to add, remove and search for data in issues. These functions are
handled by the following methods.</p>
<p lang="en-GB" class="c5"><span class="c6"># search the items and
display any that match the string</span></p>
<p lang="en-GB" class="c5"><span class="c6">def search(self,
string):</span></p>
<p lang="en-GB" class="c5"><span class="c6">for i in
self._issues:</span></p>
<p lang="en-GB" class="c5"><span class="c6">if
i.search(string):</span></p>
<p lang="en-GB" class="c5"><span class="c6">print(i)</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6"># add an
issue</span></p>
<p lang="en-GB" class="c5"><span class="c6">def add_issue(self,
issue):</span></p>
<p lang="en-GB" class="c5"><span class="c6">self._issues.append(issue)</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6"># remove an
issue</span></p>
<p lang="en-GB" class="c5"><span class="c6">def remove_issue(self,
index):</span></p>
<p lang="en-GB" class="c5"><span class="c6">if index &lt;
len(self._issues):</span></p>
<p lang="en-GB" class="c5"><span class="c6">del
self._issues[index]</span></p>
<p lang="en-GB" class="western">The search method loops through
all the issues in the project and uses the issue classes
<b class="calibre2">search</b> method to check if it should display the issue.</p>
<p lang="en-GB" class="western">The <b class="calibre2">add_issue</b> method
simply appends the passed issue to the list.</p>
<p lang="en-GB" class="western">The <b class="calibre2">remove_issue</b> method
checks that the passed index is valid and if it is then deletes the
issue at the passed index.</p>
<p lang="en-GB" class="western">The rest of the methods are self
explanatory setter and getter functions.</p>
<p lang="en-GB" class="c5"><span class="c6">def
get_title(self):</span></p>
<p lang="en-GB" class="c5"><span class="c6">return
self._title</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">def
get_number_issues(self):</span></p>
<p lang="en-GB" class="c5"><span class="c6">return
len(self._issues)</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">def update_issue(self,
index, issue):</span></p>
<p lang="en-GB" class="c5"><span class="c6">if index &lt;
len(self._issues):</span></p>
<p lang="en-GB" class="c5"><span class="c6">self._issues[index] =
issue</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">def get_issue(self,
index):</span></p>
<p lang="en-GB" class="c5"><span class="c6">if index &lt;
len(self._issues):</span></p>
<p lang="en-GB" class="c5"><span class="c6">return
self._issues[index]</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">def
get_details(self):</span></p>
<p lang="en-GB" class="c5"><span class="c6">return
self._title</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">def
display_issue(self, index):</span></p>
<p lang="en-GB" class="c5"><span class="c6">if index &lt;
len(self._issues):</span></p>
<p lang="en-GB" class="c5"><span class="c6">print(self._issues[index])</span></p>
<p lang="en-GB" class="western">So having defined the classes to
store projects and issues the program needs to provide a way to
allow the used to enter and view the data. This is will be done via
the command line, the constructor for the BugTracker class is shown
below</p>
<p lang="en-GB" class="c5"><span class="c6">NO_PROJECT =
0xffffffff</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">def
__init__(self):</span></p>
<p lang="en-GB" class="c5"><span class="c6">"""Constructor"""</span></p>
<p lang="en-GB" class="c5"><span class="c6">self._projects =
[]</span></p>
<p lang="en-GB" class="c5"><span class="c6">self._currentProject =
self.NO_PROJECT</span></p>
<p lang="en-GB" class="western">The constructor has two instant
variables the first is a list to contain the projects and the
second is an index which will be used to select the currently
selected project.</p>
<p lang="en-GB" class="c5"><span class="c6">def
command_interface(self):</span></p>
<p lang="en-GB" class="c5"><span class="c6">"""The main command
loop runs until exit is entered"""</span></p>
<p lang="en-GB" class="c5"><span class="c6">print('Bug
Tracker')</span></p>
<p lang="en-GB" class="c5"><span class="c6">inputstr =
''</span></p>
<p lang="en-GB" class="c5"><span class="c6">while inputstr !=
'exit':</span></p>
<p lang="en-GB" class="c5"><span class="c6">inputstr =
input('&gt;')</span></p>
<p lang="en-GB" class="c5"><span class="c6">self.parsemessage(inputstr)</span></p>
<p lang="en-GB" class="western">The <b class="calibre2">command_interface</b>
<span class="c9">method</span> is very simple it simply waits for
input, if the the user enters 'exit' the script terminates,
otherwise the input sting is sent to the <b class="calibre2">parsemessage</b>
method.</p>
<p lang="en-GB" class="c5"><span class="c6">def parsemessage(self,
inputstr):</span></p>
<p lang="en-GB" class="c5"><span class="c6">"""Parses the command
line input"""</span></p>
<p lang="en-GB" class="c5"><span class="c6">if inputstr == 'new
project' or inputstr == 'np':</span></p>
<p lang="en-GB" class="c5"><span class="c6">self.new_project()</span></p>
<p lang="en-GB" class="c5"><span class="c6">elif inputstr == 'view
projects' or inputstr == 'vp':</span></p>
<p lang="en-GB" class="c5"><span class="c6">self.view_projects()</span></p>
<p lang="en-GB" class="c5"><span class="c6">elif inputstr ==
'select project' or inputstr == 'sp':</span></p>
<p lang="en-GB" class="c5"><span class="c6">self.select_project()</span></p>
<p lang="en-GB" class="c5"><span class="c6">elif inputstr == 'new
issue' or inputstr == 'ni':</span></p>
<p lang="en-GB" class="c5"><span class="c6">self.new_issue()</span></p>
<p lang="en-GB" class="c5"><span class="c6">elif inputstr == 'view
issues' or inputstr == 'vs':</span></p>
<p lang="en-GB" class="c5"><span class="c6">self.view_issues()</span></p>
<p lang="en-GB" class="c5"><span class="c6">elif inputstr == 'view
issue' or inputstr == 'vi':</span></p>
<p lang="en-GB" class="c5"><span class="c6">self.view_issue()</span></p>
<p lang="en-GB" class="c5"><span class="c6">elif inputstr == 'edit
issue' or inputstr == 'ei':</span></p>
<p lang="en-GB" class="c5"><span class="c6">self.edit_issue()</span></p>
<p lang="en-GB" class="c5"><span class="c6">elif inputstr ==
'search issue' or inputstr == 'si':</span></p>
<p lang="en-GB" class="c5"><span class="c6">self.search_issue()</span></p>
<p lang="en-GB" class="c5"><span class="c6">elif inputstr ==
'save' or inputstr == 'sa':</span></p>
<p lang="en-GB" class="c5"><span class="c6">self.save_project()</span></p>
<p lang="en-GB" class="c5"><span class="c6">elif inputstr ==
'load' or inputstr == 'lo':</span></p>
<p lang="en-GB" class="c5"><span class="c6">self.load_project()</span></p>
<p lang="en-GB" class="c5"><span class="c6">elif inputstr ==
'help' or inputstr == '?':</span></p>
<p lang="en-GB" class="c5"><span class="c6">self.help()</span></p>
<p lang="en-GB" class="c5"><span class="c6">else:</span></p>
<p lang="en-GB" class="c5"><span class="c6">print("?")</span></p>
<p lang="en-GB" class="western">The <b class="calibre2">parsemessage</b> method
compares the passed string with the available commands if no match
is found then it displays a question mark otherwise it calls the
method to run the command.</p>
<p lang="en-GB" class="western">To allow the user to select
items from a list they will need to enter a number which will then
get converted from the string to an numeric value. The
<b class="calibre2">input_number</b> method handles entry of numbers and checking
that the values are within range.</p>
<p lang="en-GB" class="c5"><span class="c6">def input_number(self,
description, maxvalue):</span></p>
<p lang="en-GB" class="c5"><span class="c6">"""Allows input if a
number and verifies its with range"""</span></p>
<p lang="en-GB" class="c5"><span class="c6">desstr =
input(description)</span></p>
<p lang="en-GB" class="c5"><span class="c6">try:</span></p>
<p lang="en-GB" class="c5"><span class="c6"># convert to
int</span></p>
<p lang="en-GB" class="c5"><span class="c6">value =
int(desstr)</span></p>
<p lang="en-GB" class="c5"><span class="c6"># Check
range</span></p>
<p lang="en-GB" class="c5"><span class="c6">if value &lt;=
maxvalue:</span></p>
<p lang="en-GB" class="c5"><span class="c6">return True,
value</span></p>
<p lang="en-GB" class="c5"><span class="c6">except
ValueError:</span></p>
<p lang="en-GB" class="c5"><span class="c6">print('?')</span></p>
<p lang="en-GB" class="c5"><span class="c6">return False,
0</span></p>
<p lang="en-GB" class="c5"><span class="c6">else:</span></p>
<p lang="en-GB" class="c5"><span class="c6">print('?')</span></p>
<p lang="en-GB" class="c5"><span class="c6">return False,
0</span></p>
<p lang="en-GB" class="western">The value is entered by the user
with the input command, the value is then converted to an integer,
this is done inside a <b class="calibre2">try-except</b> in case the conversion
causes an exception. The value is then checked against the maximum
value allowed if it is valid then the method returns True to show
it is valid and the value. If an error occurs or the value is
invalid then False is returned to show there has been an error and
the return value is 0.</p>
<p lang="en-GB" class="western">The program needs to allow the
user to create new projects this will be done with the <span class="c11">new_project</span> method</p>
<p lang="en-GB" class="c5"><span class="c6">def
new_project(self):</span></p>
<p lang="en-GB" class="c5"><span class="c6">"""Creates a new
project"""</span></p>
<p lang="en-GB" class="c5"><span class="c6">inputstr =
input('Project Name:')</span></p>
<p lang="en-GB" class="c5"><span class="c6"># if nothing is
entered so don't create a project</span></p>
<p lang="en-GB" class="c5"><span class="c6">if inputstr ==
"":</span></p>
<p lang="en-GB" class="c5"><span class="c6">print("No project
created")</span></p>
<p lang="en-GB" class="c5"><span class="c6">else:</span></p>
<p lang="en-GB" class="c5"><span class="c6">x =
Project(inputstr)</span></p>
<p lang="en-GB" class="c5"><span class="c6">self._projects.append(x)</span></p>
<p lang="en-GB" class="western">The <b class="calibre2">new_project</b> method
allows the user to enter a project name, if they don't enter any
text then no project is created, otherwise a new project is created
and added to the <b class="calibre2">_projects</b> instance variable.</p>
<p lang="en-GB" class="c5"><span class="c6">def
view_projects(self):</span></p>
<p lang="en-GB" class="c5"><span class="c6">"""Lists all the
current projects"""</span></p>
<p lang="en-GB" class="c5"><span class="c6">if len(self._projects)
== 0:</span></p>
<p lang="en-GB" class="c5"><span class="c6">print("No
projects..")</span></p>
<p lang="en-GB" class="c5"><span class="c6">else:</span></p>
<p lang="en-GB" class="c5"><span class="c6">for i in
self._projects:</span></p>
<p lang="en-GB" class="c5"><span class="c6">print(i.get_title())</span></p>
<p lang="en-GB" class="western">The <b class="calibre2">view_projects</b> method
checks if any projects have been defined, if there are no projects
then it prints an error message otherwise it uses a <b class="calibre2">for</b> loop
to iterate through all the projects and display the their
titles.</p>
<p lang="en-GB" class="western">The final project related method
defined below allows the user to select the current project so they
can add or view the projects issues.</p>
<p lang="en-GB" class="c5"><span class="c6">def
select_project(self):</span></p>
<p lang="en-GB" class="c5"><span class="c6">"""Selects a project
from a list"""</span></p>
<p lang="en-GB" class="c5"><span class="c6">print("Projects:")</span></p>
<p lang="en-GB" class="c5"><span class="c6">if len(self._projects)
== 0:</span></p>
<p lang="en-GB" class="c5"><span class="c6">print("No
projects..")</span></p>
<p lang="en-GB" class="c5"><span class="c6">else:</span></p>
<p lang="en-GB" class="c5"><span class="c6"># display all the
projects</span></p>
<p lang="en-GB" class="c5"><span class="c6">for (index, i) in
enumerate(self._projects):</span></p>
<p lang="en-GB" class="c5"><span class="c6">print(" ", index, " -
", i.get_title())</span></p>
<p lang="en-GB" class="c5"><span class="c6"># select the
project</span></p>
<p lang="en-GB" class="c5"><span class="c6">success, i =
self.input_number("Select Project: ",
len(self._projects))</span></p>
<p lang="en-GB" class="c5"><span class="c6">if success:</span></p>
<p lang="en-GB" class="c5"><span class="c6">self._currentProject =
i</span></p>
<p lang="en-GB" class="c5"><span class="c6">else:</span></p>
<p lang="en-GB" class="c5"><span class="c6">print("?")</span></p>
<p lang="en-GB" class="western">The method first checks that a
project has been defined if not it displays an error message and
exits, otherwise it displays a list of the projects. The user can
then enter the number of the project they want to select, if the
number entry is successful then <b class="calibre2">_currentProject</b> is set to
the selected project.</p>
<p lang="en-GB" class="western">To handle editing issues there
needs to be a similar set of methods to those for the project. The
first one is a method to add an issue to the currently selected
project.</p>
<p lang="en-GB" class="c5"><span class="c6">def
new_issue(self):</span></p>
<p lang="en-GB" class="c5"><span class="c6">"""Creates a new
issue"""</span></p>
<p lang="en-GB" class="c5"><span class="c6">if
self._currentProject == self.NO_PROJECT:</span></p>
<p lang="en-GB" class="c5"><span class="c6">print('No project
selected')</span></p>
<p lang="en-GB" class="c5"><span class="c6">else:</span></p>
<p lang="en-GB" class="c5"><span class="c6"># select the type of
project</span></p>
<p lang="en-GB" class="c5"><span class="c6">success, typeid =
self.select_type("Select Issue Type: ")</span></p>
<p lang="en-GB" class="c5"><span class="c6">if success:</span></p>
<p lang="en-GB" class="c5"><span class="c6"># input the
title</span></p>
<p lang="en-GB" class="c5"><span class="c6">title = input('Title:
')</span></p>
<p lang="en-GB" class="c5"><span class="c6"># check the title is
ok</span></p>
<p lang="en-GB" class="c5"><span class="c6">if title !=
"":</span></p>
<p lang="en-GB" class="c5"><span class="c6"># input the
description</span></p>
<p lang="en-GB" class="c5"><span class="c6">details =
input('Details: ')</span></p>
<p lang="en-GB" class="c5"><span class="c6">project =
self._projects[self._currentProject]</span></p>
<p lang="en-GB" class="c5"><span class="c6"># create the
issue</span></p>
<p lang="en-GB" class="c5"><span class="c6">issue = Issue(typeid,
title, details)</span></p>
<p lang="en-GB" class="c5"><span class="c6"># add the issue to the
project</span></p>
<p lang="en-GB" class="c5"><span class="c6">project.add_issue(issue)</span></p>
<p lang="en-GB" class="c5"><span class="c6">return</span></p>
<p lang="en-GB" class="c5"><span class="c6"># An error
occurred</span></p>
<p lang="en-GB" class="c5"><span class="c6">print("?")</span></p>
<p lang="en-GB" class="western">This method checks that a
current project is selected, if there is a selected project then
the user is asked to enter the type of issue, the title and a
description. If the user doesn't enter any of the required
information then a '?' is displayed and the method exits otherwise
the new issue is added to the currently selected project.</p>
<p lang="en-GB" class="western">As well as creating issues the
program needs to allow users to edit issues as they work on the
them. The <b class="calibre2">edit_issue</b> method allows an issue to be
edited.</p>
<p lang="en-GB" class="c5"><span class="c6">def
edit_issue(self):</span></p>
<p lang="en-GB" class="c5"><span class="c6">"""Allows the user to
select an issue and edit it"""</span></p>
<p lang="en-GB" class="c5"><span class="c6">if
self._currentProject == self.NO_PROJECT:</span></p>
<p lang="en-GB" class="c5"><span class="c6">print('No project
selected')</span></p>
<p lang="en-GB" class="c5"><span class="c6">else:</span></p>
<p lang="en-GB" class="c5"><span class="c6"># select an
issue</span></p>
<p lang="en-GB" class="c5"><span class="c6">success, issueindex =
self.select_issue()</span></p>
<p lang="en-GB" class="c5"><span class="c6">if success:</span></p>
<p lang="en-GB" class="c5"><span class="c6"># get the
issue</span></p>
<p lang="en-GB" class="c5"><span class="c6">project =
self._projects[self._currentProject]</span></p>
<p lang="en-GB" class="c5"><span class="c6">issue =
project.get_issue(issueindex)</span></p>
<p lang="en-GB" class="c5"><span class="c6"># get the
type</span></p>
<p lang="en-GB" class="c5"><span class="c6">desstr = 'Select Issue
Type: ' + issue.get_type() + ': '</span></p>
<p lang="en-GB" class="c5"><span class="c6">success, typeid =
self.select_type(desstr)</span></p>
<p lang="en-GB" class="c5"><span class="c6">if success:</span></p>
<p lang="en-GB" class="c5"><span class="c6">issue.set_type(typeid)</span></p>
<p lang="en-GB" class="c5"><span class="c6"># get the
state</span></p>
<p lang="en-GB" class="c5"><span class="c6">success, stateid =
self.select_status(desstr)</span></p>
<p lang="en-GB" class="c5"><span class="c6">if success:</span></p>
<p lang="en-GB" class="c5"><span class="c6">issue.set_state(stateid)</span></p>
<p lang="en-GB" class="c5"><span class="c6"># input the
title</span></p>
<p lang="en-GB" class="c5"><span class="c6">title = input('Title:
' + issue.get_title() + ': ')</span></p>
<p lang="en-GB" class="c5"><span class="c6"># check the title is
ok</span></p>
<p lang="en-GB" class="c5"><span class="c6">if title !=
'':</span></p>
<p lang="en-GB" class="c5"><span class="c6">issue.set_title(title)</span></p>
<p lang="en-GB" class="c5"><span class="c6">details =
input('Details: ' + issue.get_details() + ': ')</span></p>
<p lang="en-GB" class="c5"><span class="c6">if details !=
'':</span></p>
<p lang="en-GB" class="c5"><span class="c6">issue.set_details(title)</span></p>
<p lang="en-GB" class="c5"><span class="c6">project.update_issue(issue)</span></p>
<p lang="en-GB" class="c5"><span class="c6">else:</span></p>
<p lang="en-GB" class="c5"><span class="c6">print('?')</span></p>
<p lang="en-GB" class="western">The method starts by displaying
a list of the issues and allowing the user to select the one they
want to edit. If an invalid issue is selected the method prints a
'?' and exits. If a valid issue is selected then the method steps
through each field in turn to allow the information to be updated,
if they choose to skip a field by not entering anything then the
method continues to the next field without altering the current
field.</p>
<p lang="en-GB" class="western">If you look at the code you'll
notice that the following three methods are called these methods
have the functionality to select an issue, type value or status
value. This functionality is required in several places in the
project module so it makes sense to create separate methods rather
than rewriting the code every time. Since they also provide a
particular defined function even if they are not called in separate
places it would make the code clearer to to split a larger method
by moving this functionality into a separate block.</p>
<p lang="en-GB" class="c5"><span class="c6">def
select_issue(self):</span></p>
<p lang="en-GB" class="c5"><span class="c6">"""Allows selection of
an image from a list"""</span></p>
<p lang="en-GB" class="c5"><span class="c6"># list the
issues</span></p>
<p lang="en-GB" class="c5"><span class="c6">self.view_issues()</span></p>
<p lang="en-GB" class="c5"><span class="c6">project =
self._projects[self._currentProject]</span></p>
<p lang="en-GB" class="c5"><span class="c6">return
self.input_number('Select Issue: ',
project.get_number_issues())</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">def select_type(self,
desc):</span></p>
<p lang="en-GB" class="c5"><span class="c6">"""Allows selection of
issue type"""</span></p>
<p lang="en-GB" class="c5"><span class="c6"># print the
types</span></p>
<p lang="en-GB" class="c5"><span class="c6">for i in
range(Issue.get_number_types()):</span></p>
<p lang="en-GB" class="c5"><span class="c6">print(i,
Issue.get_type_str(i))</span></p>
<p lang="en-GB" class="c5"><span class="c6"># get the
type</span></p>
<p lang="en-GB" class="c5"><span class="c6">return
self.input_number(desc, Issue.get_number_types())</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">def
select_status(self, desstr):</span></p>
<p lang="en-GB" class="c5"><span class="c6">"""Allows selection of
issue status"""</span></p>
<p lang="en-GB" class="c5"><span class="c6">for i in
range(Issue.get_number_states()):</span></p>
<p lang="en-GB" class="c5"><span class="c6">print(i,
Issue.get_state_str(i))</span></p>
<p lang="en-GB" class="c5"><span class="c6">return
self.input_number(desstr, Issue.get_number_types())</span></p>
<p lang="en-GB" class="western">The methods are all similar they
display a list and then wait for user to select an item from the
list using the <b class="calibre2">input_number</b> method.</p>
<p lang="en-GB" class="western">The final issue related method
that will be defined is one to search the projects issues to find
an instance of a string in either the title or description.</p>
<p lang="en-GB" class="c5"><span class="c6">def
search_issue(self):</span></p>
<p lang="en-GB" class="c5"><span class="c6">"""Allows searching in
all issue with a string"""</span></p>
<p lang="en-GB" class="c5"><span class="c6">if
self._currentProject == self.NO_PROJECT:</span></p>
<p lang="en-GB" class="c5"><span class="c6">print('No project
selected')</span></p>
<p lang="en-GB" class="c5"><span class="c6">else:</span></p>
<p lang="en-GB" class="c5"><span class="c6">project =
self._projects[self._currentProject]</span></p>
<p lang="en-GB" class="c5"><span class="c6">search = input("Search
For:")</span></p>
<p lang="en-GB" class="c5"><span class="c6">project.search(search)</span></p>
<p lang="en-GB" class="western">There wouldn't be much point in
entering data if you can't save it, the following methods allow the
user to load and save the projects.</p>
<p lang="en-GB" class="c5"><span class="c6">def
save_project(self):</span></p>
<p lang="en-GB" class="c5"><span class="c6">"""Saves all the
projects"""</span></p>
<p lang="en-GB" class="c5"><span class="c6">filename =
input('Filename :')</span></p>
<p lang="en-GB" class="c5"><span class="c6">if filename !=
'':</span></p>
<p lang="en-GB" class="c5"><span class="c6"># open a
file</span></p>
<p lang="en-GB" class="c5"><span class="c6">myfile =
open(filename, "wb")</span></p>
<p lang="en-GB" class="c5"><span class="c6">if
myfile.close:</span></p>
<p lang="en-GB" class="c5"><span class="c6">print('Can\'t open
file!')</span></p>
<p lang="en-GB" class="c5"><span class="c6">else:</span></p>
<p lang="en-GB" class="c5"><span class="c6">pickle.dump(self._projects, myfile)</span></p>
<p lang="en-GB" class="c5"><span class="c6">pickle.dump(self._currentProject, myfile)</span></p>
<p lang="en-GB" class="c5"><span class="c6">myfile.close()</span></p>
<p lang="en-GB" class="c5"><span class="c6">print('File
Saved')</span></p>
<p lang="en-GB" class="c7"> <br class="calibre1"/></p>
<p lang="en-GB" class="c5"><span class="c6">def
load_project(self):</span></p>
<p lang="en-GB" class="c5"><span class="c6">"""loads all the
projects"""</span></p>
<p lang="en-GB" class="c5"><span class="c6">filename =
input('Filename :')</span></p>
<p lang="en-GB" class="c5"><span class="c6">if filename !=
'':</span></p>
<p lang="en-GB" class="c5"><span class="c6"># open a
file</span></p>
<p lang="en-GB" class="c5"><span class="c6">myfile =
open(filename, "rb")</span></p>
<p lang="en-GB" class="c5"><span class="c6">if
myfile.close:</span></p>
<p lang="en-GB" class="c5"><span class="c6">print('Can\'t open
file!')</span></p>
<p lang="en-GB" class="c5"><span class="c6">else:</span></p>
<p lang="en-GB" class="c5"><span class="c6">self._projects =
pickle.load(myfile)</span></p>
<p lang="en-GB" class="c5"><span class="c6">self._currentProject =
pickle.load(myfile)</span></p>
<p lang="en-GB" class="c5"><span class="c6">myfile.close()</span></p>
<p lang="en-GB" class="c5"><span class="c6">print('File
loaded')</span></p>
<p lang="en-GB" class="western">The methods uses pickle to save
and load the projects and issues.</p>
<p lang="en-GB" class="western">This is obviously a fairly
simple implementation of a bug tracker it can be expanded to allow
searching for open issues or issues created before a different date
etc.</p>
<p lang="en-GB" class="western">The full listing is given in
Appendix 3.</p>
<p lang="en-GB" class="western"><br class="calibre1"/>
<br class="calibre1"/></p>
<p lang="en-GB" class="western"><br class="calibre1"/>
<br class="calibre1"/></p>
<p lang="en-GB" class="western"><br class="calibre1"/>
<br class="calibre1"/></p>
<p lang="en-GB" class="western"><br class="calibre1"/>
<br class="calibre1"/></p>
</body>
</html>

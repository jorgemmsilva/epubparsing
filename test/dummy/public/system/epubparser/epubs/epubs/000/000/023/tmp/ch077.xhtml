<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Count number of ways to cover a distance</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="count-number-of-ways-to-cover-a-distance" class="section level1">
<h1>Count number of ways to cover a distance</h1>
<p>Given a distance â€˜dist, count total number of ways to cover the distance with 1, 2 and 3 steps.</p>
<p>Examples:</p>
<pre><code> 
Input:  n = 3
Output: 4
Below are the four ways
 1 step + 1 step + 1 step
 1 step + 2 step
 2 step + 1 step
 3 step

Input:  n = 4
Output: 7
 </code></pre>
<p><strong>We strongly recommend you to minimize your browser and try this yourself first.</strong></p>
<pre><code> 
// A naive recursive C++ program to count number of ways to cover
// a distance with 1, 2 and 3 steps
#include&lt;iostream&gt;
using namespace std;

// Returns count of ways to cover &#39;dist&#39;
int printCountRec(int dist)
{
    // Base cases
    if (dist&lt;0)    return 0;
    if (dist==0)  return 1;

    // Recur for all previous 3 and add the results
    return printCountRec(dist-1) +
           printCountRec(dist-2) +
           printCountRec(dist-3);
}

// driver program
int main()
{
    int dist = 4;
    cout &lt;&lt; printCountRec(dist);
    return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> 7 </code></pre>
<p>The time complexity of above solution is exponential, a close upper bound is O(3<sup>n</sup>). If we draw the complete recursion tree, we can observer that many subproblems are solved again and again. For example, when we start from n = 6, we can reach 4 by subtracting one 2 times and by subtracting 2 one times. So the subproblem for 4 is called twice.<br /> Since same suproblems are called again, this problem has Overlapping Subprolems property. So min square sum problem has both properties (see <a href="http://www.geeksforgeeks.org/archives/12635">this</a>and <a href="http://www.geeksforgeeks.org/archives/12819">this</a>) of a dynamic programming problem. Like other typical <a href="http://www.geeksforgeeks.org/archives/tag/dynamic-programming">Dynamic Programming(DP) problems</a>, recomputations of same subproblems can be avoided by constructing a temporary array count[] in bottom up manner.</p>
<p>Below is Dynamic Programming based C++ implementation.</p>
<pre><code> 
// A Dynamic Programming based C++ program to count number of ways
// to cover a distance with 1, 2 and 3 steps
#include&lt;iostream&gt;
using namespace std;

int printCountDP(int dist)
{
    int count[dist+1];

    // Initialize base values. There is one way to cover 0 and 1
    // distances and two ways to cover 2 distance
    count[0]  = 1,  count[1] = 1,  count[2] = 2;

    // Fill the count array in bottom up manner
    for (int i=3; i&lt;=dist; i++)
       count[i] = count[i-1] + count[i-2] + count[i-3];

    return count[dist];
}

// driver program
int main()
{
    int dist = 4;
    cout &lt;&lt; printCountDP(dist);
    return 0;
}
 </code></pre>
<p>Output: 4</p>
<p>This article is contributed by Vignesh Venkatesan. <a href="https://in.linkedin.com/in/vignesh4430"></a>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<p><br /></p>
<div id="source-76" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/count-number-of-ways-to-cover-a-distance/" class="uri">http://www.geeksforgeeks.org/count-number-of-ways-to-cover-a-distance/</a></p>
<p><span>Category: <a href="http://www.geeksforgeeks.org/category/c-programs/">Misc</a></span> <span>Tags: <a href="http://www.geeksforgeeks.org/tag/dynamic-programming/">Dynamic Programming</a></span></p>
</div>
</div>
</body>
</html>


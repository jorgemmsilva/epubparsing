<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Weighted Job Scheduling</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="weighted-job-scheduling" class="section level1">
<h1>Weighted Job Scheduling</h1>
<p>Given N jobs where every job is represented by following three elements of it.<br /> 1) Start Time<br /> 2) Finish Time.<br /> 3) Profit or Value Associated.<span id="more-133754"></span><br /> Find the maximum profit subset of jobs such that no two jobs in the subset overlap.</p>
<p>Example:</p>
<pre><code> 
Input: Number of Jobs n = 4
       Job Details {Start Time, Finish Time, Profit}
       Job 1:  {1, 2, 50} 
       Job 2:  {3, 5, 20}
       Job 3:  {6, 19, 100}
       Job 4:  {2, 100, 200}
Output: The maximum profit is 250.
We can get the maximum profit by scheduling jobs 1 and 4.
Note that there is longer schedules possible Jobs 1, 2 and 3 
but the profit with this schedule is 20+50+100 which is less than 250.  </code></pre>
<p>A simple version of this problem is discussed <a href="http://www.geeksforgeeks.org/greedy-algorithms-set-1-activity-selection-problem/">here</a>where every job has same profit or value. The <a href="http://www.geeksforgeeks.org/greedy-algorithms-set-1-activity-selection-problem/">Greedy Strategy for activity selection</a> doesn’t work here as the longer schedule may have smaller profit or value.</p>
<p>The above problem can be solved using following recursive solution.</p>
<pre><code> 
1) First sort jobs according to finish time.
2) Now apply following recursive process. 
   // Here arr[] is array of n jobs
   findMaximumProfit(arr[], n)
   {
     a) if (n == 1) return arr[0];
     b) Return the maximum of following two profits.
         (i) Maximum profit by excluding current job, i.e., 
             findMaximumProfit(arr, n-1)
         (ii) Maximum profit by including the current job            
   }

How to find the profit including current job?
The idea is to find the latest job before the current job (in 
sorted array) that doesn&#39;t conflict with current job &#39;arr[n-1]&#39;. 
Once we find such a job, we recur for all jobs till that job and
add profit of current job to result.
In the above example, &quot;job 1&quot; is the latest non-conflicting
for &quot;job 4&quot; and &quot;job 2&quot; is the latest non-conflicting for &quot;job 3&quot;.
  </code></pre>
<p>The following is C++ implementation of above naive recursive method.</p>
<pre><code> 
// C++ program for weighted job scheduling using Naive Recursive Method
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

// A job has start time, finish time and profit.
struct Job
{
    int start, finish, profit;
};

// A utility function that is used for sorting events
// according to finish time
bool myfunction(Job s1, Job s2)
{
    return (s1.finish &lt; s2.finish);
}

// Find the latest job (in sorted array) that doesn&#39;t
// conflict with the job[i]. If there is no compatible job,
// then it returns -1.
int latestNonConflict(Job arr[], int i)
{
    for (int j=i-1; j&gt;=0; j--)
    {
        if (arr[j].finish &lt;= arr[i-1].start)
            return j;
    }
    return -1;
}

// A recursive function that returns the maximum possible
// profit from given array of jobs.  The array of jobs must
// be sorted according to finish time.
int findMaxProfitRec(Job arr[], int n)
{
    // Base case
    if (n == 1) return arr[n-1].profit;

    // Find profit when current job is inclueded
    int inclProf = arr[n-1].profit;
    int i = latestNonConflict(arr, n);
    if (i != -1)
      inclProf += findMaxProfitRec(arr, i+1);

    // Find profit when current job is excluded
    int exclProf = findMaxProfitRec(arr, n-1);

    return max(inclProf,  exclProf);
}

// The main function that returns the maximum possible
// profit from given array of jobs
int findMaxProfit(Job arr[], int n)
{
    // Sort jobs according to finish time
    sort(arr, arr+n, myfunction);

    return findMaxProfitRec(arr, n);
}

// Driver program
int main()
{
    Job arr[] = {{3, 10, 20}, {1, 2, 50}, {6, 19, 100}, {2, 100, 200}};
    int n = sizeof(arr)/sizeof(arr[0]);
    cout &lt;&lt; &quot;The optimal profit is &quot; &lt;&lt; findMaxProfit(arr, n);
    return 0;
} </code></pre>
<p>Output:</p>
<pre><code> The optimal profit is 250 </code></pre>
<p>The above solution may contain many overlapping subproblems. For example if lastNonConflicting() always returns previous job, then findMaxProfitRec(arr, n-1) is called twice and the time complexity becomes O(n*2<sup>n</sup>). As another example when lastNonConflicting() returns previous to previous job, there are two recursive calls, for n-2 and n-1. In this example case, recursion becomes same as Fibonacci Numbers.<br /> So this problem has both properties of Dynamic Programming, <a href="http://www.geeksforgeeks.org/dynamic-programming-set-2-optimal-substructure-property/">Optimal Substructure</a>and <a href="http://www.geeksforgeeks.org/dynamic-programming-set-1/">Overlapping Subproblems</a>.<br /> Like other Dynamic Programming Problems, we can solve this problem by making a table that stores solution of subproblems.</p>
<p>Below is C++ implementation based on Dynamic Programming.</p>
<pre><code> 
// C++ program for weighted job scheduling using Dynamic Programming.
#include &lt;iostream&gt;
#include &lt;algorithm&gt;
using namespace std;

// A job has start time, finish time and profit.
struct Job
{
    int start, finish, profit;
};

// A utility function that is used for sorting events
// according to finish time
bool myfunction(Job s1, Job s2)
{
    return (s1.finish &lt; s2.finish);
}

// Find the latest job (in sorted array) that doesn&#39;t
// conflict with the job[i]
int latestNonConflict(Job arr[], int i)
{
    for (int j=i-1; j&gt;=0; j--)
    {
        if (arr[j].finish &lt;= arr[i].start)
            return j;
    }
    return -1;
}

// The main function that returns the maximum possible
// profit from given array of jobs
int findMaxProfit(Job arr[], int n)
{
    // Sort jobs according to finish time
    sort(arr, arr+n, myfunction);

    // Create an array to store solutions of subproblems.  table[i]
    // stores the profit for jobs till arr[i] (including arr[i])
    int *table = new int[n];
    table[0] = arr[0].profit;

    // Fill entries in M[] using recursive property
    for (int i=1; i&lt;n; i++)
    {
        // Find profit including the current job
        int inclProf = arr[i].profit;
        int l = latestNonConflict(arr, i);
        if (l != -1)
            inclProf += table[l];

        // Store maximum of including and excluding
        table[i] = max(inclProf, table[i-1]);
    }

    // Store result and free dynamic memory allocated for table[]
    int result = table[n-1];
    delete[] table;

    return result;
}

// Driver program
int main()
{
    Job arr[] = {{3, 10, 20}, {1, 2, 50}, {6, 19, 100}, {2, 100, 200}};
    int n = sizeof(arr)/sizeof(arr[0]);
    cout &lt;&lt; &quot;The optimal profit is &quot; &lt;&lt; findMaxProfit(arr, n);
    return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> 
The optimal profit is 250
 </code></pre>
<p>Time Complexity of the above Dynamic Programming Solution is O(n<sup>2</sup>). Note that the above solution can be optimized to O(nLogn) using Binary Search in latestNonConflict() instead of linear search. Thanks to Garvit for suggesting this optimization.</p>
<p><strong>References:</strong><br /> <a href="http://courses.cs.washington.edu/courses/cse521/13wi/slides/06dp-sched.pdf" class="uri">http://courses.cs.washington.edu/courses/cse521/13wi/slides/06dp-sched.pdf</a></p>
<p>This article is contributed by Shivam. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<p><br /></p>
<div id="source-54" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/weighted-job-scheduling/" class="uri">http://www.geeksforgeeks.org/weighted-job-scheduling/</a></p>
<p><span>Category: <a href="http://www.geeksforgeeks.org/category/c-arrays/">Arrays</a></span> <span>Tags: <a href="http://www.geeksforgeeks.org/tag/dynamic-programming/">Dynamic Programming</a></span></p>
<p><br /></p>
<p>Post navigation</p>
<p><span class="nav-previous"><a href="http://www.geeksforgeeks.org/optimal-read-list-given-number-days/"><span class="meta-nav">←</span> Optimal read list for given number of days</a></span> <span class="nav-next"><a href="http://www.geeksforgeeks.org/housing-com-interview-experience-set-3-campus/">Housing.com Interview Experience | Set 3 (On-Campus) <span class="meta-nav">→</span></a></span></p>
<p>Writing code in comment? Please use <a href="http://code.geeksforgeeks.org/">code.geeksforgeeks.org</a>, generate link and share the link here.</p>
</div>
</div>
</body>
</html>


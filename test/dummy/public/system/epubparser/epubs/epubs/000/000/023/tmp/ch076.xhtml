<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Count even length binary sequences with same sum of first and second half bits</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="count-even-length-binary-sequences-with-same-sum-of-first-and-second-half-bits" class="section level1">
<h1>Count even length binary sequences with same sum of first and second half bits</h1>
<p>Given a number n, find count of all binary sequences of length 2n such that sum of first n bits is same as sum of last n bits.<span id="more-135618"></span></p>
<p>Examples:</p>
<pre><code> 
Input:  n = 1
Output: 2
There are 2 sequences of length 2*n, the
sequences are 00 and 11

Input:  n = 2
Output: 2
There are 6 sequences of length 2*n, the
sequences are 0101, 0110, 1010, 1001, 0000
and 1111
 </code></pre>
<p><strong>We strongly recommend you to minimize your browser and try this yourself first.</strong></p>
<p>The idea is to fix first and last bits and then recur for n-1, i.e., remaining 2(n-1) bits. There are following possibilities when we fix first and last bits.<br /> 1) First and last bits are same, remaining n-1 bits on both sides should also have the <strong>same</strong> sum.<br /> 2) First bit is 1 and last bit is 0, sum of remaining n-1 bits on left side should be 1 <strong>less</strong> than the sum n-1 bits on right side.<br /> 2) First bit is 0 and last bit is 1, sum of remaining n-1 bits on left side should be 1 <strong>more</strong> than the sum n-1 bits on right side.</p>
<p>Based on above facts, we get below recurrence formula.</p>
<p><strong>diff</strong> is the expected difference between sum of first half digits and last half digits. Initially diff is 0.</p>
<pre><code> 
                  // When first and last bits are same
                  // there are two cases, 00 and 11
count(n, diff) =  2*count(n-1, diff) +    
    
                 // When first bit is 1 and last bit is 0
                 count(n-1, diff-1) +

                 // When first bit is 0 and last bit is 1
                 count(n-1, diff+1)

What should be base cases?
// When n == 1 (2 bit sequences)
1) If n == 1 and diff == 0, return 2
2) If n == 1 and |diff| == 1, return 1 

// We can&#39;t cover difference of more than n with 2n bits
3) If |diff| &gt; n, return 0
 </code></pre>
<p>Below is C++ implementation based of above <strong>Naive Recursive Solution</strong>.</p>
<pre><code> 
// A Naive Recursive C++ program to count even
// length binary sequences such that the sum of
// first and second half bits is same
#include&lt;bits/stdc++.h&gt;
using namespace std;

// diff is difference between sums first n bits
// and last n bits respectively
int countSeq(int n, int diff)
{
    // We can&#39;t cover difference of more
    // than n with 2n bits
    if (abs(diff) &gt; n)
        return 0;

    // n == 1, i.e., 2 bit long sequences
    if (n == 1 &amp;&amp; diff == 0)
        return 2;
    if (n == 1 &amp;&amp; abs(diff) == 1)
        return 1;

    int res = // First bit is 0 &amp; last bit is 1
              countSeq(n-1, diff+1) +

              // First and last bits are same
              2*countSeq(n-1, diff) +

              // First bit is 1 &amp; last bit is 0
              countSeq(n-1, diff-1);

    return res;
}

// Driver program
int main()
{
    int n = 2;
    cout &lt;&lt; &quot;Count of sequences is &quot;
         &lt;&lt; countSeq(2, 0);
    return 0;
}
 </code></pre>
<p>Output</p>
<pre><code> Count of sequences is 6 </code></pre>
<p>The time complexity of above solution is exponential. If we draw the complete recursion tree, we can observer that many subproblems are solved again and again. For example, when we start from n = 4 and diff = 0, we can reach (3, 0) through multiple paths. Since same suproblems are called again, this problem has Overlapping Subprolems property. So min square sum problem has both properties (see <a href="http://www.geeksforgeeks.org/archives/12635">this</a>and <a href="http://www.geeksforgeeks.org/archives/12819">this</a>) of a <strong>Dynamic Programming</strong> problem.<br /> Below is a memoization based solution that uses a lookup table to compute the result.</p>
<pre><code> 
// A memoization based C++ program to count even
// length binary sequences such that the sum of
// first and second half bits is same
#include&lt;bits/stdc++.h&gt;
using namespace std;
#define MAX 1000

// A lookup table to store the results of subproblems
int lookup[MAX][MAX];

// dif is diference between sums of first n bits
// and last n bits i.e., dif = (Sum of first n bits) -
//                              (Sum of last n bits)
int countSeqUtil(int n, int dif)
{
    // We can&#39;t cover diference of more
    // than n with 2n bits
    if (abs(dif) &gt; n)
        return 0;

    // n == 1, i.e., 2 bit long sequences
    if (n == 1 &amp;&amp; dif == 0)
        return 2;
    if (n == 1 &amp;&amp; abs(dif) == 1)
        return 1;

    // Check if this subbproblem is already solved
    // n is added to dif to make sure index becomes
    // positive
    if (lookup[n][n+dif] != -1)
        return lookup[n][n+dif];

    int res = // First bit is 0 &amp; last bit is 1
              countSeqUtil(n-1, dif+1) +

              // First and last bits are same
              2*countSeqUtil(n-1, dif) +

              // First bit is 1 &amp; last bit is 0
              countSeqUtil(n-1, dif-1);

    // Store result in lookup table and return the result
    return lookup[n][n+dif] = res;
}

// A Wrapper over countSeqUtil().  It mainly initializes lookup
// table, then calls countSeqUtil()
int countSeq(int n)
{
    // Initialize all entries of lookup table as not filled
    memset(lookup, -1, sizeof(lookup));

    // call countSeqUtil()
    return countSeqUtil(n, 0);
}

// Driver program
int main()
{
    int n = 2;
    cout &lt;&lt; &quot;Count of sequences is &quot;
         &lt;&lt; countSeq(2);
    return 0;
}
 </code></pre>
<p>Output</p>
<pre><code> Count of sequences is 6 </code></pre>
<p>Worst case time complexity of this solution is O(n<sup>2</sup>) as diff can be maximum n.</p>
<p><br /> Below is <strong>O(n) solution</strong> for the same.</p>
<pre><code> 
Number of n-bit strings with 0 ones = nC0
Number of n-bit strings with 1 ones = nC1
...
Number of n-bit strings with k ones = nCk
...
Number of n-bit strings with n ones = nCn  </code></pre>
<p>So, we can get required result using below</p>
<pre><code> 
No. of 2*n bit strings such that first n bits have 0 ones &amp; 
last n bits have 0 ones = nC0 * nC0

No. of 2*n bit strings such that first n bits have 1 ones &amp; 
last n bits have 1 ones = nC1 * nC1

....

and so on.

Result = nC0*nC0 + nC1*nC1 + ... + nCn*nCn
       = &amp;Sum;(nCk)2 
        0 
Below is C++ implementation based on above idea.
 
// A O(n) C++ program to count even length binary sequences
// such that the sum of first and second half bits is same
#include&lt;iostream&gt;
using namespace std;

// Returns the count of even length sequences
int countSeq(int n)
{
    int nCr=1, res = 1;

    // Calculate SUM ((nCr)^2)
    for (int r = 1; r&lt;=n ; r++)
    {
        // Compute nCr using nC(r-1)
        // nCr/nC(r-1) = (n+1-r)/r;
        nCr = (nCr * (n+1-r))/r;   

        res += nCr*nCr;
    }

    return res;
}

// Driver program
int main()
{
    int n = 3;
    cout &lt;&lt; &quot;Count of sequences is &quot;
         &lt;&lt; countSeq(n);
    return 0;
} </code></pre>
<p>Output</p>
<pre><code> Count of sequences is 6 </code></pre>
<p>Thanks to d_geeks, Saurabh Jain and Mysterious Mind for suggesting above O(n) solution.</p>
<p>This article is contributed by Pawan. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<p><br /></p>
<div id="source-75" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/count-even-length-binary-sequences-with-same-sum-of-first-and-second-half-bits/" class="uri">http://www.geeksforgeeks.org/count-even-length-binary-sequences-with-same-sum-of-first-and-second-half-bits/</a></p>
<p><span>Category: <a href="http://www.geeksforgeeks.org/category/c-programs/">Misc</a></span> <span>Tags: <a href="http://www.geeksforgeeks.org/tag/dynamic-programming/">Dynamic Programming</a></span></p>
<p><br /></p>
<p>Post navigation</p>
<p><span class="nav-previous"><a href="http://www.geeksforgeeks.org/10-mistakes-people-tend-to-do-in-an-interview/"><span class="meta-nav">←</span> 10 mistakes people tend to do in an Interview</a></span> <span class="nav-next"><a href="http://www.geeksforgeeks.org/adobe-interview-experience-set-30-off-campus-for-member-technical-staff/">Adobe Interview Experience | Set 30 (Off-Campus For Member Technical Staff) <span class="meta-nav">→</span></a></span></p>
<p>Writing code in comment? Please use <a href="http://code.geeksforgeeks.org/">code.geeksforgeeks.org</a>, generate link and share the link here.</p>
</div>
</div>
</body>
</html>


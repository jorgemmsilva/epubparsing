<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Count Possible Decodings of a given Digit Sequence</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="count-possible-decodings-of-a-given-digit-sequence" class="section level1">
<h1>Count Possible Decodings of a given Digit Sequence</h1>
<p>Let 1 represent ‘A’, 2 represents ‘B’, etc. Given a digit sequence, count the number of possible decodings of the given digit sequence. <span id="more-130134"></span></p>
<p>Examples:</p>
<pre><code> 
Input:  digits[] = &quot;121&quot;
Output: 3
// The possible decodings are &quot;ABA&quot;, &quot;AU&quot;, &quot;LA&quot;

Input: digits[] = &quot;1234&quot;
Output: 3
// The possible decodings are &quot;ABCD&quot;, &quot;LCD&quot;, &quot;AWD&quot; </code></pre>
<p>An empty digit sequence is considered to have one decoding. It may be assumed that the input contains valid digits from 0 to 9 and there are no leading 0’s, no extra trailing 0’s and no two or more consecutive 0’s.</p>
<p><strong>We strongly recommend to minimize the browser and try this yourself first.</strong></p>
<p>This problem is recursive and can be broken in sub-problems. We start from end of the given digit sequence. We initialize the total count of decodings as 0. We recur for two subproblems.<br /> 1) If the last digit is non-zero, recur for remaining (n-1) digits and add the result to total count.<br /> 2) If the last two digits form a valid character (or smaller than 27), recur for remaining (n-2) digits and add the result to total count.</p>
<p>Following is C++ implementation of the above approach.</p>
<pre><code> 
// A naive recursive C++ implementation to count number of decodings
// that can be formed from a given digit sequence
#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

// Given a digit sequence of length n, returns count of possible
// decodings by replacing 1 with A, 2 woth B, ... 26 with Z
int countDecoding(char *digits, int n)
{
    // base cases
    if (n == 0 || n == 1)
        return 1;

    int count = 0;  // Initialize count

    // If the last digit is not 0, then last digit must add to
    // the number of words
    if (digits[n-1] &gt; &#39;0&#39;)
        count =  countDecoding(digits, n-1);

    // If the last two digits form a number smaller than or equal to 26,
    // then consider last two digits and recur
    if (digits[n-2] &lt; &#39;2&#39; || (digits[n-2] == &#39;2&#39; &amp;&amp; digits[n-1] &lt; &#39;7&#39;) )
        count +=  countDecoding(digits, n-2);

    return count;
}

// Driver program to test above function
int main()
{
    char digits[] = &quot;1234&quot;;
    int n = strlen(digits);
    cout &lt;&lt; &quot;Count is &quot; &lt;&lt; countDecoding(digits, n);
    return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> Count is 3 </code></pre>
<p>The time complexity of above the code is exponential. If we take a closer look at the above program, we can observe that the recursive solution is similar to <a href="http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/">Fibonacci Numbers</a>. Therefore, we can optimize the above solution to work in O(n) time using <a href="http://www.geeksforgeeks.org/tag/dynamic-programming/">Dynamic Programming</a>. Following is C++ implementation for the same.</p>
<pre><code> 
// A Dynamic Programming based C++ implementation to count decodings
#include &lt;iostream&gt;
#include &lt;cstring&gt;
using namespace std;

// A Dynamic Programming based function to count decodings
int countDecodingDP(char *digits, int n)
{
    int count[n+1]; // A table to store results of subproblems
    count[0] = 1;
    count[1] = 1;

    for (int i = 2; i &lt;= n; i++)
    {
        count[i] = 0;

        // If the last digit is not 0, then last digit must add to
        // the number of words
        if (digits[i-1] &gt; &#39;0&#39;)
            count[i] = count[i-1];

        // If second last digit is smaller than 2 and last digit is
        // smaller than 7, then last two digits form a valid character
        if (digits[i-2] &lt; &#39;2&#39; || (digits[i-2] == &#39;2&#39; &amp;&amp; digits[i-1] &lt; &#39;7&#39;) )
            count[i] += count[i-2];
    }
    return count[n];
}

// Driver program to test above function
int main()
{
    char digits[] = &quot;1234&quot;;
    int n = strlen(digits);
    cout &lt;&lt; &quot;Count is &quot; &lt;&lt; countDecodingDP(digits, n);
    return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> Count is 3 </code></pre>
<p>Time Complexity of the above solution is O(n) and it requires O(n) auxiliary space. We can reduce auxiliary space to O(1) by using space optimized version discussed in the <a href="http://www.geeksforgeeks.org/program-for-nth-fibonacci-number/">Fibonacci Number Post</a>.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<p><br /></p>
<div id="source-48" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/count-possible-decodings-given-digit-sequence/" class="uri">http://www.geeksforgeeks.org/count-possible-decodings-given-digit-sequence/</a></p>
<p><span>Category: <a href="http://www.geeksforgeeks.org/category/c-strings/">Strings</a></span> <span>Tags: <a href="http://www.geeksforgeeks.org/tag/dynamic-programming/">Dynamic Programming</a>, <a href="http://www.geeksforgeeks.org/tag/fibonacci-numbers/">Fibonacci numbers</a>, <a href="http://www.geeksforgeeks.org/tag/mathematicalalgo/">MathematicalAlgo</a></span></p>
</div>
</div>
</body>
</html>


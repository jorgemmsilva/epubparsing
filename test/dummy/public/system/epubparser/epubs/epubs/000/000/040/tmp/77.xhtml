<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Bitmasking and Dynamic Programming | Set 1 (Count ways to assign unique cap to every person)</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="bitmasking-and-dynamic-programming-set-1-count-ways-to-assign-unique-cap-to-every-person" class="section level1">
<h1>Bitmasking and Dynamic Programming | Set 1 (Count ways to assign unique cap to every person)</h1>
<p>Consider the below problems statement.</p>
<p>There 100 different types of caps each having a unique id from 1 to 100. Also, there ‘n’ persons each having a collection of variable number of caps. <span id="more-135378"></span>One day all of these persons decide to go in a party wearing a cap but to look unique they decided that none them will wear the same type of cap. So, count the total number of arrangements or ways such that none of them is wearing same type of cap.</p>
<p>Constraints: 1 First line contains value of n, next n lines contain collections of all the n persons. Input: 3 5 100 1 // Collection of first person. 2 // Collection of second person. 5 100 // Collection of second person. Output: 4 Explanation: All valid possible ways are (5, 2, 100), (100, 2, 5), (1, 2, 5) and (1, 2, 100)</p>
<p>Since, number of ways could be large, so output modulo 1000000007</p>
<p><strong>We strongly recommend you to minimize your browser and try this yourself first.</strong><br /> A <strong>Simple Solution</strong> is to try all possible combinations. Start by picking first element from first set, marking it as visited and recur for remaining sets. It is basically a Backtracking based solution.</p>
<p>A <strong>better solution is to use Bitmasking and DP</strong>. Let us first introduce Bitmasking.</p>
<p><strong>What is Bitmasking?</strong><br /> Suppose we have a collection of elements which are numbered from 1 to N. If we want to represent a subset of this set than it can be encoded by a sequence of N bits (we usually call this sequence a “mask”). In our chosen subset the i-th element belongs to it if and only if the i-th bit of the mask I set i.e., it equals to 1. For example, the mask 10000101 means that the subset of the set [1… 8] consists of elements 1, 3 and 8. We know that for a set of N elements there are total 2<sup>N</sup> subsets thus 2<sup>N</sup> masks are possible, one representing each subset. Each mask is in fact an integer number written in binary notation.</p>
<p>Our main methodology is to assign a value to each mask (and, therefore, to each subset) and thus calculate the values for new masks using values of the already computed masks. Usually our main target is to calculate value/solution for the complete set i.e., for mask 11111111. Normally, to find the value for a subset X we remove an element in every possible way and use values for obtained subsets X’<sub>1</sub>, X’<sub>2</sub>… ,X’<sub>k</sub> to compute the value/solution for X. This means that the values for X’<sub>i</sub> must have been computed already, so we need to establish an ordering in which masks will be considered. It’s easy to see that the natural ordering will do: go over masks in increasing order of corresponding numbers. Also, We sometimes, start with the empty subset X and we add elements in every possible way and use the values of obtained subsets X’<sub>1</sub>, X’<sub>2</sub>… ,X’<sub>k</sub> to compute the value/solution for X.</p>
<p>We mostly use the following notations/operations on masks:<br /> bit(i,mask) – the i-th bit of mask<br /> count(mask) – the number of non-zero bits in mask<br /> first(mask) – the number of the lowest non-zero bit in mask<br /> set(i, mask) – set the ith bit in mask<br /> check(i, mask) – check the ith bit in mask</p>
<p><strong>How is this problem solved using Bitmasking + DP?</strong><br /> The idea is to use the fact that there are upto 10 persons. So we can use a integer variable as a bitmask to store which person is wearing cap and which is not.</p>
<pre><code> 
Let i be the current cap number (caps from 1 to i-1 are already 
processed). Let integer variable mask indicates the the persons w
earing and not wearing caps.  If i&#39;th bit is set in mask, then 
i&#39;th person is wearing a cap, else not.

             // consider the case when ith cap is not included 
                     // in the arrangement
countWays(mask, i) = countWays(mask, i+1) +             
                    
                    // when ith cap is included in the arrangement
                    // so, assign this cap to all possible persons 
                    // one by one and recur for remaining persons.
                    &amp;Sum; countWays(mask | (1 
If we draw the complete recursion tree, we can observer that many subproblems are solved again and again.  So we use Dynamic Programming.  A table dp[][] is used such that in every entry dp[i][j], i is mask and j is cap number. 
Since we want to access all persons that can wear a given cap, we use an array of vectors, capList[101].  A value capList[i] indicates the list of persons that can wear cap i.
Below is C++ implementation of above idea.
 
// C++ program to find number of ways to wear hats
#include&lt;bits/stdc++.h&gt;
#define MOD 1000000007
using namespace std;

// capList[i]&#39;th vector contains the list of persons having a cap with id i
// id is between 1 to 100 so we declared an array of 101 vectors as indexing
// starts from 0.
vector&lt;int&gt; capList[101];

// dp[2^10][101] .. in dp[i][j], i denotes the mask i.e., it tells that
// how many and which persons are wearing cap. j denotes the first j caps
// used. So, dp[i][j] tells the number ways we assign j caps to mask i
// such that none of them wears the same cap
int dp[1025][101];

// This is used for base case, it has all the N bits set
// so, it tells whether all N persons are wearing a cap.
int allmask;

// Mask is the set of persons, i is the number of
// caps processed starting from first cap.
long long int countWaysUtil(int mask, int i)
{
    // If all persons are wearing a cap so we
    // are done and this is one way so return 1
    if (mask == allmask) return 1;

    // If not everyone is wearing a cap and also there are no more
    // caps left to process, so there is no way, thus return 0;
    if (i &gt; 100) return 0;

    // If we already have solved this subproblem, return the answer.
    if (dp[mask][i] != -1) return dp[mask][i];

    // Ways, when we don&#39;t include this cap in our arrangement
    // or solution set.
    long long int ways = countWaysUtil(mask, i+1);

    // size is the total number of persons having cap with id i.
    int size = capList[i].size();

    // So, assign one by one ith cap to all the possible persons
    // and recur for remaining caps.
    for (int j = 0; j &lt; size; j++)
    {
        // if person capList[i][j] is already wearing a cap so continue as
        // we cannot assign him this cap
        if (mask &amp; (1 &lt;&lt; capList[i][j])) continue;

        // Else assign him this cap and recur for remaining caps with
        // new updated mask vector
        else ways += countWaysUtil(mask | (1 &lt;&lt; capList[i][j]), i+1);
        ways %= MOD;
    }

    // Save the result and return it.
    return dp[mask][i] = ways;
}

// Reads n lines from standard input for current test case
void countWays(int n)
{
    //----------- READ INPUT --------------------------
    string temp, str;
    int x;
    getline(cin, str);  // to get rid of newline character
    for (int i=0; i&lt;n; i++)
    {
        getline(cin, str);
        stringstream ss(str);

        // while there are words in the streamobject ss
        while (ss &gt;&gt; temp)
        {
            stringstream s;
            s &lt;&lt; temp;
            s &gt;&gt; x;

            // add the ith person in the list of cap if with id x
            capList[x].push_back(i);
        }
    }
    //----------------------------------------------------

    // All mask is used to check of all persons
    // are included or not, set all n bits as 1
    allmask = (1 &lt;&lt; n) - 1;

    // Initialize all entries in dp as -1
    memset(dp, -1, sizeof dp);

    // Call recursive function count ways
    cout &lt;&lt; countWaysUtil(0, 1) &lt;&lt; endl;
}

// Driver Program
int main()
{ 
     int n;   // number of persons in every test case
     cin &gt;&gt; n;
     countWays(n);
     return 0;
}
 </code></pre>
<p>Input:</p>
<pre><code> 
3               
5 100 1         
2               
5 100 </code></pre>
<p>Output:</p>
<pre><code> 
4 </code></pre>
<p>This article is contributed by <a href="http://qa.geeksforgeeks.org/user/Mr.Lazy">Gaurav Ahirwar</a>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<p><br /></p>
<div id="source-73" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/bitmasking-and-dynamic-programming-set-1-count-ways-to-assign-unique-cap-to-every-person/" class="uri">http://www.geeksforgeeks.org/bitmasking-and-dynamic-programming-set-1-count-ways-to-assign-unique-cap-to-every-person/</a></p>
</div>
</div>
</body>
</html>


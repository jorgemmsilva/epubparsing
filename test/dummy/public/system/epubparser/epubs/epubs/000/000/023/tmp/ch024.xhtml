<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Dynamic Programming | Set 17 (Palindrome Partitioning)</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="dynamic-programming-set-17-palindrome-partitioning" class="section level1">
<h1>Dynamic Programming | Set 17 (Palindrome Partitioning)</h1>
<p>Given a string, a partitioning of the string is a <em>palindrome partitioning</em> if every substring of the partition is a palindrome. <span id="more-20293"></span>For example, “aba|b|bbabb|a|b|aba” is a palindrome partitioning of “ababbbabbababa”. Determine the fewest cuts needed for palindrome partitioning of a given string. For example, minimum 3 cuts are needed for “ababbbabbababa”. The three cuts are “a|babbbab|b|ababa”. If a string is palindrome, then minimum 0 cuts are needed. If a string of length n containing all different characters, then minimum n-1 cuts are needed.</p>
<p><strong>Solution</strong><br /> This problem is a variation of <a href="http://www.geeksforgeeks.org/archives/15553">Matrix Chain Multiplication</a> problem. If the string is palindrome, then we simply return 0. Else, like the Matrix Chain Multiplication problem, we try making cuts at all possible places, recursively calculate the cost for each cut and return the minimum value.</p>
<p>Let the given string be str and minPalPartion() be the function that returns the fewest cuts needed for palindrome partitioning. following is the optimal substructure property.</p>
<pre><code> 
// i is the starting index and j is the ending index. i must be passed as 0 and j as n-1
minPalPartion(str, i, j) = 0 if i == j. // When string is of length 1.
minPalPartion(str, i, j) = 0 if str[i..j] is palindrome.

// If none of the above conditions is true, then minPalPartion(str, i, j) can be 
// calculated recursively using the following formula.
minPalPartion(str, i, j) = Min { minPalPartion(str, i, k) + 1 +
                                 minPalPartion(str, k+1, j) } 
                           where k varies from i to j-1
 </code></pre>
<p>Following is Dynamic Programming solution. It stores the solutions to subproblems in two arrays P[][] and C[][], and reuses the calculated values.</p>
<pre><code> 
// Dynamic Programming Solution for Palindrome Partitioning Problem
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;limits.h&gt;
 
// A utility function to get minimum of two integers
int min (int a, int b) { return (a &lt; b)? a : b; }
 
// Returns the minimum number of cuts needed to partition a string
// such that every part is a palindrome
int minPalPartion(char *str)
{
    // Get the length of the string
    int n = strlen(str);
 
    /* Create two arrays to build the solution in bottom up manner
       C[i][j] = Minimum number of cuts needed for palindrome partitioning
                 of substring str[i..j]
       P[i][j] = true if substring str[i..j] is palindrome, else false
       Note that C[i][j] is 0 if P[i][j] is true */
    int C[n][n];
    bool P[n][n];
 
    int i, j, k, L; // different looping variables
 
    // Every substring of length 1 is a palindrome
    for (i=0; i&lt;n; i++)
    {
        P[i][i] = true;
        C[i][i] = 0;
    }
 
    /* L is substring length. Build the solution in bottom up manner by
       considering all substrings of length starting from 2 to n.
       The loop structure is same as Matrx Chain Multiplication problem (
       See http://www.geeksforgeeks.org/archives/15553 )*/
    for (L=2; L&lt;=n; L++)
    {
        // For substring of length L, set different possible starting indexes
        for (i=0; i&lt;n-L+1; i++)
        {
            j = i+L-1; // Set ending index
 
            // If L is 2, then we just need to compare two characters. Else
            // need to check two corner characters and value of P[i+1][j-1]
            if (L == 2)
                P[i][j] = (str[i] == str[j]);
            else
                P[i][j] = (str[i] == str[j]) &amp;&amp; P[i+1][j-1];
 
            // IF str[i..j] is palindrome, then C[i][j] is 0
            if (P[i][j] == true)
                C[i][j] = 0;
            else
            {
                // Make a cut at every possible localtion starting from i to j,
                // and get the minimum cost cut.
                C[i][j] = INT_MAX;
                for (k=i; k&lt;=j-1; k++)
                    C[i][j] = min (C[i][j], C[i][k] + C[k+1][j]+1);
            }
        }
    }
 
    // Return the min cut value for complete string. i.e., str[0..n-1]
    return C[0][n-1];
}
 
// Driver program to test above function
int main()
{
   char str[] = &quot;ababbbabbababa&quot;;
   printf(&quot;Min cuts needed for Palindrome Partitioning is %d&quot;,
           minPalPartion(str));
   return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> 
Min cuts needed for Palindrome Partitioning is 3  </code></pre>
<p>Time Complexity: O(n<sup>3</sup>)</p>
<p><strong>An optimization to above approach</strong><br /> In above approach, we can calculating minimum cut while finding all palindromic substring. If we finding all palindromic substring 1<sup>st</sup> and then we calculate minimum cut, time complexity will reduce to O(n<sup>2</sup>).<br /> Thanks for <strong><a href="http://www.geeksforgeeks.org/dynamic-programming-set-17-palindrome-partitioning/#comment-1459162424">Vivek</a></strong> for suggesting this optimization.</p>
<pre><code> 
// Dynamic Programming Solution for Palindrome Partitioning Problem
#include &lt;stdio.h&gt;
#include &lt;string.h&gt;
#include &lt;limits.h&gt;
 
// A utility function to get minimum of two integers
int min (int a, int b) { return (a &lt; b)? a : b; }
 
// Returns the minimum number of cuts needed to partition a string
// such that every part is a palindrome
int minPalPartion(char *str)
{
    // Get the length of the string
    int n = strlen(str);
 
    /* Create two arrays to build the solution in bottom up manner
       C[i] = Minimum number of cuts needed for palindrome partitioning
                 of substring str[0..i]
       P[i][j] = true if substring str[i..j] is palindrome, else false
       Note that C[i] is 0 if P[0][i] is true */
    int C[n];
    bool P[n][n];
 
    int i, j, k, L; // different looping variables
 
    // Every substring of length 1 is a palindrome
    for (i=0; i&lt;n; i++)
    {
        P[i][i] = true;
    }
 
    /* L is substring length. Build the solution in bottom up manner by
       considering all substrings of length starting from 2 to n. */
    for (L=2; L&lt;=n; L++)
    {
        // For substring of length L, set different possible starting indexes
        for (i=0; i&lt;n-L+1; i++)
        {
            j = i+L-1; // Set ending index
 
            // If L is 2, then we just need to compare two characters. Else
            // need to check two corner characters and value of P[i+1][j-1]
            if (L == 2)
                P[i][j] = (str[i] == str[j]);
            else
                P[i][j] = (str[i] == str[j]) &amp;&amp; P[i+1][j-1];
        }
    }

    for (i=0; i&lt;n; i++)
    {
        if (P[0][i] == true)
            C[i] = 0;
        else
        {
            C[i] = INT_MAX;
            for(j=0;j&lt;i;j++)
            {
                if(P[j+1][i] == true &amp;&amp; 1+C[j]&lt;C[i])
                    C[i]=1+C[j];
            }
        }
    }
 
    // Return the min cut value for complete string. i.e., str[0..n-1]
    return C[n-1];
}
 
// Driver program to test above function
int main()
{
   char str[] = &quot;ababbbabbababa&quot;;
   printf(&quot;Min cuts needed for Palindrome Partitioning is %d&quot;,
           minPalPartion(str));
   return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> 
Min cuts needed for Palindrome Partitioning is 3  </code></pre>
<p>Time Complexity: O(n<sup>2</sup>)</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<p><br /></p>
<div id="source-22" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/dynamic-programming-set-17-palindrome-partitioning/" class="uri">http://www.geeksforgeeks.org/dynamic-programming-set-17-palindrome-partitioning/</a></p>
<p><span>Category: <a href="http://www.geeksforgeeks.org/category/c-strings/">Strings</a></span> <span>Tags: <a href="http://www.geeksforgeeks.org/tag/dynamic-programming/">Dynamic Programming</a></span></p>
<p><br /></p>
<p>Post navigation</p>
<p><span class="nav-previous"><a href="http://www.geeksforgeeks.org/operating-systems-set-13/"><span class="meta-nav">←</span> Operating Systems | Set 13</a></span> <span class="nav-next"><a href="http://www.geeksforgeeks.org/operating-systems-set-14/">Operating Systems | Set 14 <span class="meta-nav">→</span></a></span></p>
<p>Writing code in comment? Please use <a href="http://code.geeksforgeeks.org/">code.geeksforgeeks.org</a>, generate link and share the link here.</p>
</div>
</div>
</body>
</html>


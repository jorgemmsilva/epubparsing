<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Shortest path with exactly k edges in a directed and weighted graph</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="shortest-path-with-exactly-k-edges-in-a-directed-and-weighted-graph" class="section level1">
<h1>Shortest path with exactly k edges in a directed and weighted graph</h1>
<p>Given a directed and two vertices ‘u’ and ‘v’ in it, find shortest path from ‘u’ to ‘v’ with exactly k edges on the path.<span id="more-130858"></span></p>
<p>The graph is given as <a href="http://www.geeksforgeeks.org/graph-and-its-representations/">adjacency matrix representation</a> where value of graph[i][j] indicates the weight of an edge from vertex i to vertex j and a value INF(infinite) indicates no edge from i to j.</p>
<p>For example consider the following graph. Let source ‘u’ be vertex 0, destination ‘v’ be 3 and k be 2. There are two walks of length 2, the walks are {0, 2, 3} and {0, 1, 3}. The shortest among the two is {0, 2, 3} and weight of path is 3+6 = 9.</p>
<p><a href="http://d2hc1qfcrygj4j.cloudfront.net//wp-content/uploads/graph11.png"><img src="media/file30.png" alt="graph1" /></a></p>
<p>The idea is to browse through all paths of length k from u to v using the approach discussed in the <a href="http://www.geeksforgeeks.org/count-possible-paths-source-destination-exactly-k-edges/">previous post</a> and return weight of the shortest path. A <strong>simple solution</strong> is to start from u, go to all adjacent vertices and recur for adjacent vertices with k as k-1, source as adjacent vertex and destination as v. Following is C++ implementation of this simple solution.</p>
<pre><code> 
// C++ program to find shortest path with exactly k edges
#include &lt;iostream&gt;
#include &lt;climits&gt;
using namespace std;

// Define number of vertices in the graph and inifinite value
#define V 4
#define INF INT_MAX

// A naive recursive function to count walks from u to v with k edges
int shortestPath(int graph[][V], int u, int v, int k)
{
   // Base cases
   if (k == 0 &amp;&amp; u == v)             return 0;
   if (k == 1 &amp;&amp; graph[u][v] != INF) return graph[u][v];
   if (k &lt;= 0)                       return INF;

   // Initialize result
   int res = INF;

   // Go to all adjacents of u and recur
   for (int i = 0; i &lt; V; i++)
   {
       if (graph[u][i] != INF &amp;&amp; u != i &amp;&amp; v != i)
       {
           int rec_res = shortestPath(graph, i, v, k-1);
           if (rec_res != INF)
              res = min(res, graph[u][i] + rec_res);
       }
   }
   return res;
}

// driver program to test above function
int main()
{
    /* Let us create the graph shown in above diagram*/
     int graph[V][V] = { {0, 10, 3, 2},
                        {INF, 0, INF, 7},
                        {INF, INF, 0, 6},
                        {INF, INF, INF, 0}
                      };
    int u = 0, v = 3, k = 2;
    cout &lt;&lt; &quot;Weight of the shortest path is &quot; &lt;&lt;
          shortestPath(graph, u, v, k);
    return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> Weight of the shortest path is 9 </code></pre>
<p>The worst case time complexity of the above function is O(V<sup>k</sup>) where V is the number of vertices in the given graph. We can simply analyze the time complexity by drawing recursion tree. The worst occurs for a complete graph. In worst case, every internal node of recursion tree would have exactly V children.<br /> We can optimize the above solution using <strong><a href="http://www.geeksforgeeks.org/dynamic-programming-set-1/">Dynamic Programming</a></strong>. The idea is to build a 3D table where first dimension is source, second dimension is destination, third dimension is number of edges from source to destination, and the value is count of walks. Like other <a href="http://www.geeksforgeeks.org/tag/dynamic-programming/">Dynamic Programming problems</a>, we fill the 3D table in bottom up manner.</p>
<pre><code> 
// Dynamic Programming based C++ program to find shortest path with
// exactly k edges
#include &lt;iostream&gt;
#include &lt;climits&gt;
using namespace std;

// Define number of vertices in the graph and inifinite value
#define V 4
#define INF INT_MAX

// A Dynamic programming based function to find the shortest path from
// u to v with exactly k edges.
int shortestPath(int graph[][V], int u, int v, int k)
{
    // Table to be filled up using DP. The value sp[i][j][e] will store
    // weight of the shortest path from i to j with exactly k edges
    int sp[V][V][k+1];

    // Loop for number of edges from 0 to k
    for (int e = 0; e &lt;= k; e++)
    {
        for (int i = 0; i &lt; V; i++)  // for source
        {
            for (int j = 0; j &lt; V; j++) // for destination
            {
                // initialize value
                sp[i][j][e] = INF;

                // from base cases
                if (e == 0 &amp;&amp; i == j)
                    sp[i][j][e] = 0;
                if (e == 1 &amp;&amp; graph[i][j] != INF)
                    sp[i][j][e] = graph[i][j];

                //go to adjacent only when number of edges is more than 1
                if (e &gt; 1)
                {
                    for (int a = 0; a &lt; V; a++)
                    {
                        // There should be an edge from i to a and a 
                        // should not be same as either i or j
                        if (graph[i][a] != INF &amp;&amp; i != a &amp;&amp;
                            j!= a &amp;&amp; sp[a][j][e-1] != INF)
                          sp[i][j][e] = min(sp[i][j][e], graph[i][a] +
                                                       sp[a][j][e-1]);
                    }
                }
           }
        }
    }
    return sp[u][v][k];
}

// driver program to test above function
int main()
{
    /* Let us create the graph shown in above diagram*/
     int graph[V][V] = { {0, 10, 3, 2},
                        {INF, 0, INF, 7},
                        {INF, INF, 0, 6},
                        {INF, INF, INF, 0}
                      };
    int u = 0, v = 3, k = 2;
    cout &lt;&lt; shortestPath(graph, u, v, k);
    return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> Weight of the shortest path is 9 </code></pre>
<p>Time complexity of the above DP based solution is O(V<sup>3</sup>K) which is much better than the naive solution.</p>
<p>This article is contributed by <strong>Abhishek</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<p><br /></p>
<div id="source-50" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/shortest-path-exactly-k-edges-directed-weighted-graph/" class="uri">http://www.geeksforgeeks.org/shortest-path-exactly-k-edges-directed-weighted-graph/</a></p>
<p><span>Category: <a href="http://www.geeksforgeeks.org/category/graph/">Graph</a></span> <span>Tags: <a href="http://www.geeksforgeeks.org/tag/dynamic-programming/">Dynamic Programming</a></span></p>
<p><br /></p>
<p>Post navigation</p>
<p><span class="nav-previous"><a href="http://www.geeksforgeeks.org/connect-n-ropes-minimum-cost/"><span class="meta-nav">←</span> Connect n ropes with minimum cost</a></span> <span class="nav-next"><a href="http://www.geeksforgeeks.org/tarjan-algorithm-find-strongly-connected-components/">Tarjan’s Algorithm to find Strongly Connected Components <span class="meta-nav">→</span></a></span></p>
<p>Writing code in comment? Please use <a href="http://code.geeksforgeeks.org/">code.geeksforgeeks.org</a>, generate link and share the link here.</p>
</div>
</div>
</body>
</html>


<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Dynamic Programming | Set 31 (Optimal Strategy for a Game)</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="dynamic-programming-set-31-optimal-strategy-for-a-game" class="section level1">
<h1>Dynamic Programming | Set 31 (Optimal Strategy for a Game)</h1>
<p>Problem statement: Consider a row of n coins of values v1 . . . vn, where n is even. We play a game against an opponent by alternating turns. In each turn, a player selects either the first or last coin from the row,<span id="more-118853"></span> removes it from the row permanently, and receives the value of the coin. Determine the maximum possible amount of money we can definitely win if we move first.</p>
<p>Note: The opponent is as clever as the user.</p>
<p>Let us understand the problem with few examples:</p>
<p>    <strong>1.</strong> 5, 3, 7, 10 : The user collects maximum value as 15(10 + 5)</p>
<p>    <strong>2.</strong> 8, 15, 3, 7 : The user collects maximum value as 22(7 + 15)</p>
<p>Does choosing the best at each move give an optimal solution?</p>
<p>No. In the second example, this is how the game can finish:</p>
<p><strong>1.</strong><br /> …….User chooses 8.<br /> …….Opponent chooses 15.<br /> …….User chooses 7.<br /> …….Opponent chooses 3.<br /> Total value collected by user is 15(8 + 7)</p>
<p><strong>2.</strong><br /> …….User chooses 7.<br /> …….Opponent chooses 8.<br /> …….User chooses 15.<br /> …….Opponent chooses 3.<br /> Total value collected by user is 22(7 + 15)</p>
<p>So if the user follows the second game state, maximum value can be collected although the first move is not the best.</p>
<p>There are two choices:<br /> <strong>1.</strong> The user chooses the ith coin with value Vi: The opponent either chooses (i+1)th coin or jth coin. The opponent intends to choose the coin which leaves the user with minimum value.<br /> i.e. The user can collect the value Vi + min(F(i+2, j), F(i+1, j-1) )<br /> <a href="http://d2hc1qfcrygj4j.cloudfront.net//wp-content/uploads/coinGame1.png"><img src="media/file19.png" alt="coinGame1" /></a></p>
<p><strong>2.</strong> The user chooses the jth coin with value Vj: The opponent either chooses ith coin or (j-1)th coin. The opponent intends to choose the coin which leaves the user with minimum value.<br /> i.e. The user can collect the value Vj + min(F(i+1, j-1), F(i, j-2) )<br /> <a href="http://d2hc1qfcrygj4j.cloudfront.net//wp-content/uploads/coinGame21.png"><img src="media/file20.png" alt="coinGame2" /></a></p>
<p>Following is recursive solution that is based on above two choices. We take the maximum of two choices.</p>
<pre><code> 
F(i, j)  represents the maximum value the user can collect from 
         i&#39;th coin to j&#39;th coin.

    F(i, j)  = Max(Vi + min(F(i+2, j), F(i+1, j-1) ), 
                   Vj + min(F(i+1, j-1), F(i, j-2) )) 
Base Cases
    F(i, j)  = Vi           If j == i
    F(i, j)  = max(Vi, Vj)  If j == i+1 </code></pre>
<p><strong>Why Dynamic Programming?</strong><br /> The above relation exhibits overlapping sub-problems. In the above relation, F(i+1, j-1) is calculated twice.</p>
<pre><code> 
// C program to find out maximum value from a given sequence of coins
#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

// Utility functions to get maximum and minimum of two intgers
int max(int a, int b)  {    return a &gt; b ? a : b;  }
int min(int a, int b)  {    return a &lt; b ? a : b;  }

// Returns optimal value possible that a player can collect from
// an array of coins of size n. Note than n must be even
int optimalStrategyOfGame(int* arr, int n)
{
    // Create a table to store solutions of subproblems
    int table[n][n], gap, i, j, x, y, z;

    // Fill table using above recursive formula. Note that the table
    // is filled in diagonal fashion (similar to http://goo.gl/PQqoS),
    // from diagonal elements to table[0][n-1] which is the result.
    for (gap = 0; gap &lt; n; ++gap)
    {
        for (i = 0, j = gap; j &lt; n; ++i, ++j)
        {
            // Here x is value of F(i+2, j), y is F(i+1, j-1) and
            // z is F(i, j-2) in above recursive formula
            x = ((i+2) &lt;= j) ? table[i+2][j] : 0;
            y = ((i+1) &lt;= (j-1)) ? table[i+1][j-1] : 0;
            z = (i &lt;= (j-2))? table[i][j-2]: 0;

            table[i][j] = max(arr[i] + min(x, y), arr[j] + min(y, z));
        }
    }

    return table[0][n-1];
}

// Driver program to test above function
int main()
{
    int arr1[] = {8, 15, 3, 7};
    int n = sizeof(arr1)/sizeof(arr1[0]);
    printf(&quot;%d\n&quot;, optimalStrategyOfGame(arr1, n));

    int arr2[] = {2, 2, 2, 2};
    n = sizeof(arr2)/sizeof(arr2[0]);
    printf(&quot;%d\n&quot;, optimalStrategyOfGame(arr2, n));

    int arr3[] = {20, 30, 2, 2, 2, 10};
    n = sizeof(arr3)/sizeof(arr3[0]);
    printf(&quot;%d\n&quot;, optimalStrategyOfGame(arr3, n));

    return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> 22
4
42 </code></pre>
<p><strong>Exercise</strong><br /> Your thoughts on the strategy when the user wishes to only win instead of winning with the maximum value. Like above problem, number of coins is even.<br /> Can Greedy approach work quite well and give an optimal solution? Will your answer change if number of coins is odd?</p>
<p>This article is compiled by <a href="https://www.facebook.com/barnwal.aashish">Aashish Barnwal</a>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above</p>
<p><br /></p>
<div id="source-37" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/dynamic-programming-set-31-optimal-strategy-for-a-game/" class="uri">http://www.geeksforgeeks.org/dynamic-programming-set-31-optimal-strategy-for-a-game/</a></p>
</div>
</div>
</body>
</html>


<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Dynamic Programming | Set 7 (Coin Change)</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="dynamic-programming-set-7-coin-change" class="section level1">
<h1>Dynamic Programming | Set 7 (Coin Change)</h1>
<p>Given a value N, if we want to make change for N cents, and we have infinite supply of each of S = { S1, S2, .. , Sm} valued coins, how many ways can we make the change? The order of coins doesn’t matter.<span id="more-17401"></span></p>
<p>For example, for N = 4 and S = {1,2,3}, there are four solutions: {1,1,1,1},{1,1,2},{2,2},{1,3}. So output should be 4. For N = 10 and S = {2, 5, 3, 6}, there are five solutions: {2,2,2,2,2}, {2,2,3,3}, {2,2,6}, {2,3,5} and {5,5}. So the output should be 5.</p>
<p><strong>1) Optimal Substructure</strong><br /> To count total number solutions, we can divide all set solutions in two sets.<br /> 1) Solutions that do not contain mth coin (or Sm).<br /> 2) Solutions that contain at least one Sm.<br /> Let count(S[], m, n) be the function to count the number of solutions, then it can be written as sum of count(S[], m-1, n) and count(S[], m, n-Sm).</p>
<p>Therefore, the problem has optimal substructure property as the problem can be solved using solutions to subproblems.</p>
<p><strong>2) Overlapping Subproblems</strong><br /> Following is a simple recursive implementation of the Coin Change problem. The implementation simply follows the recursive structure mentioned above.</p>
<pre><code> 
#include&lt;stdio.h&gt;

// Returns the count of ways we can sum  S[0...m-1] coins to get sum n
int count( int S[], int m, int n )
{
    // If n is 0 then there is 1 solution (do not include any coin)
    if (n == 0)
        return 1;
    
    // If n is less than 0 then no solution exists
    if (n &lt; 0)
        return 0;

    // If there are no coins and n is greater than 0, then no solution exist
    if (m &lt;=0 &amp;&amp; n &gt;= 1)
        return 0;

    // count is sum of solutions (i) including S[m-1] (ii) excluding S[m-1]
    return count( S, m - 1, n ) + count( S, m, n-S[m-1] );
}

// Driver program to test above function
int main()
{
    int i, j;
    int arr[] = {1, 2, 3};
    int m = sizeof(arr)/sizeof(arr[0]);
    printf(&quot;%d &quot;, count(arr, m, 4));
    getchar();
    return 0;
}
 </code></pre>
<p>It should be noted that the above function computes the same subproblems again and again. See the following recursion tree for S = {1, 2, 3} and n = 5.<br /> The function C({1}, 3) is called two times. If we draw the complete tree, then we can see that there are many subproblems being called more than once.</p>
<pre><code> 
C() --&gt; count()
                              C({1,2,3}, 5)                     
                           /                \
                         /                   \              
             C({1,2,3}, 2)                 C({1,2}, 5)
            /     \                        /         \
           /        \                     /           \
C({1,2,3}, -1)  C({1,2}, 2)        C({1,2}, 3)    C({1}, 5)
               /     \            /    \            /     \
             /        \          /      \          /       \
    C({1,2},0)  C({1},2)   C({1,2},1) C({1},3)    C({1}, 4)  C({}, 5)
                   / \      / \       / \        /     \    
                  /   \    /   \     /   \      /       \ 
                .      .  .     .   .     .   C({1}, 3) C({}, 4)
                                               /  \
                                              /    \  
                                             .      .
 </code></pre>
<p>Since same suproblems are called again, this problem has Overlapping Subprolems property. So the Coin Change problem has both properties (see <a href="http://www.geeksforgeeks.org/archives/12635">this</a>and <a href="http://www.geeksforgeeks.org/archives/12819">this</a>) of a dynamic programming problem. Like other typical <a href="http://www.geeksforgeeks.org/archives/tag/dynamic-programming">Dynamic Programming(DP) problems</a>, recomputations of same subproblems can be avoided by constructing a temporary array table[][] in bottom up manner.</p>
<p><strong>Dynamic Programming Solution</strong></p>
<pre><code> 
#include&lt;stdio.h&gt;

int count( int S[], int m, int n )
{
    int i, j, x, y;

    // We need n+1 rows as the table is consturcted in bottom up manner using 
    // the base case 0 value case (n = 0)
    int table[n+1][m];
   
    // Fill the enteries for 0 value case (n = 0)
    for (i=0; i&lt;m; i++)
        table[0][i] = 1;

    // Fill rest of the table enteries in bottom up manner  
    for (i = 1; i &lt; n+1; i++)
    {
        for (j = 0; j &lt; m; j++)
        {
            // Count of solutions including S[j]
            x = (i-S[j] &gt;= 0)? table[i - S[j]][j]: 0;

            // Count of solutions excluding S[j]
            y = (j &gt;= 1)? table[i][j-1]: 0;

            // total count
            table[i][j] = x + y;
        }
    }
    return table[n][m-1];
}

// Driver program to test above function
int main()
{
    int arr[] = {1, 2, 3};
    int m = sizeof(arr)/sizeof(arr[0]);
    int n = 4;
    printf(&quot; %d &quot;, count(arr, m, n));
    return 0;
}
 </code></pre>
<p>Time Complexity: O(mn)</p>
<p>Following is a simplified version of method 2. The auxiliary space required here is O(n) only.</p>
<pre><code> 
int count( int S[], int m, int n )
{
    // table[i] will be storing the number of solutions for
    // value i. We need n+1 rows as the table is consturcted
    // in bottom up manner using the base case (n = 0)
    int table[n+1];

    // Initialize all table values as 0
    memset(table, 0, sizeof(table));

    // Base case (If given value is 0)
    table[0] = 1;

    // Pick all coins one by one and update the table[] values
    // after the index greater than or equal to the value of the
    // picked coin
    for(int i=0; i&lt;m; i++)
        for(int j=S[i]; j&lt;=n; j++)
            table[j] += table[j-S[i]];

    return table[n];
}
 </code></pre>
<p>Thanks to <a href="http://www.geeksforgeeks.org/archives/17401/comment-page-1#comment-7383">Rohan Laishram</a> for suggesting this space optimized version.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<p>References:<br /> <a href="http://www.algorithmist.com/index.php/Coin_Change" class="uri">http://www.algorithmist.com/index.php/Coin_Change</a></p>
<p><br /></p>
<div id="source-12" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/dynamic-programming-set-7-coin-change/" class="uri">http://www.geeksforgeeks.org/dynamic-programming-set-7-coin-change/</a></p>
<p><span>Category: <a href="http://www.geeksforgeeks.org/category/c-programs/">Misc</a></span> <span>Tags: <a href="http://www.geeksforgeeks.org/tag/dynamic-programming/">Dynamic Programming</a></span></p>
<p><br /></p>
<p>Post navigation</p>
<p><span class="nav-previous"><a href="http://www.geeksforgeeks.org/populate-inorder-successor-for-all-nodes/"><span class="meta-nav">←</span> Populate Inorder Successor for all nodes</a></span> <span class="nav-next"><a href="http://www.geeksforgeeks.org/dynamic-programming-set-8-matrix-chain-multiplication/">Dynamic Programming | Set 8 (Matrix Chain Multiplication) <span class="meta-nav">→</span></a></span></p>
<p>Writing code in comment? Please use <a href="http://code.geeksforgeeks.org/">code.geeksforgeeks.org</a>, generate link and share the link here.</p>
</div>
</div>
</body>
</html>


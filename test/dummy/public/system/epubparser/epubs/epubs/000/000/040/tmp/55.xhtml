<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Mobile Numeric Keypad Problem</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="mobile-numeric-keypad-problem" class="section level1">
<h1>Mobile Numeric Keypad Problem</h1>
<p><a href="http://d2hc1qfcrygj4j.cloudfront.net//wp-content/uploads/mobile1.png"><img src="media/file31.png" alt="mobile1" /></a>Given the mobile numeric keypad. You can only press buttons that are up, left, right or down to the current button. You are not allowed to press bottom row corner buttons (i.e. * and # ).<span id="more-131515"></span><br /> Given a number N, find out the number of possible numbers of given length.</p>
<p>Examples:<br /> For N=1, number of possible numbers would be 10 (0, 1, 2, 3, …., 9)<br /> For N=2, number of possible numbers would be 36<br /> Possible numbers: 00,08 11,12,14 22,21,23,25 and so on.<br /> If we start with 0, valid numbers will be 00, 08 (count: 2)<br /> If we start with 1, valid numbers will be 11, 12, 14 (count: 3)<br /> If we start with 2, valid numbers will be 22, 21, 23,25 (count: 4)<br /> If we start with 3, valid numbers will be 33, 32, 36 (count: 3)<br /> If we start with 4, valid numbers will be 44,41,45,47 (count: 4)<br /> If we start with 5, valid numbers will be 55,54,52,56,58 (count: 5)<br /> ………………………………<br /> ………………………………</p>
<p>We need to print the count of possible numbers.</p>
<p><strong>We strongly recommend to minimize the browser and try this yourself first.</strong></p>
<p>N = 1 is trivial case, number of possible numbers would be 10 (0, 1, 2, 3, …., 9)<br /> For N &gt; 1, we need to start from some button, then move to any of the four direction (up, left, right or down) which takes to a valid button (should not go to *, #). Keep doing this until N length number is obtained (depth first traversal).</p>
<p><strong>Recursive Solution:</strong><br /> Mobile Keypad is a rectangular grid of 4X3 (4 rows and 3 columns)<br /> Lets say Count(i, j, N) represents the count of N length numbers starting from position (i, j)</p>
<pre><code> 
If N = 1
  Count(i, j, N) = 10  
Else
  Count(i, j, N) = Sum of all Count(r, c, N-1) where (r, c) is new 
                   position after valid move of length 1 from current 
                   position (i, j) </code></pre>
<p>Following is C implementation of above recursive formula.</p>
<pre><code> 
// A Naive Recursive C program to count number of possible numbers
// of given length
#include &lt;stdio.h&gt;

// left, up, right, down move from current location
int row[] = {0, 0, -1, 0, 1};
int col[] = {0, -1, 0, 1, 0};

// Returns count of numbers of length n starting from key position
// (i, j) in a numeric keyboard.
int getCountUtil(char keypad[][3], int i, int j, int n)
{
    if (keypad == NULL || n &lt;= 0)
        return 0;

    // From a given key, only one number is possible of length 1
    if (n == 1)
        return 1;

    int k=0, move=0, ro=0, co=0, totalCount = 0;

    // move left, up, right, down from current location and if
    // new location is valid, then get number count of length
    // (n-1) from that new position and add in count obtained so far
    for (move=0; move&lt;5; move++)
    {
        ro = i + row[move];
        co = j + col[move];
        if (ro &gt;= 0 &amp;&amp; ro &lt;= 3 &amp;&amp; co &gt;=0 &amp;&amp; co &lt;= 2 &amp;&amp;
           keypad[ro][co] != &#39;*&#39; &amp;&amp; keypad[ro][co] != &#39;#&#39;)
        {
            totalCount += getCountUtil(keypad, ro, co, n-1);
        }
    }

    return totalCount;
}

// Return count of all possible numbers of length n
// in a given numeric keyboard
int getCount(char keypad[][3], int n)
{
    // Base cases
    if (keypad == NULL || n &lt;= 0)
        return 0;
    if (n == 1)
        return 10;

    int i=0, j=0, totalCount = 0;
    for (i=0; i&lt;4; i++)  // Loop on keypad row
    {
        for (j=0; j&lt;3; j++)   // Loop on keypad column
        {
            // Process for 0 to 9 digits
            if (keypad[i][j] != &#39;*&#39; &amp;&amp; keypad[i][j] != &#39;#&#39;)
            {
                // Get count when number is starting from key
                // position (i, j) and add in count obtained so far
                totalCount += getCountUtil(keypad, i, j, n);
            }
        }
    }
    return totalCount;
}

// Driver program to test above function
int main(int argc, char *argv[])
{
   char keypad[4][3] = {{&#39;1&#39;,&#39;2&#39;,&#39;3&#39;},
                        {&#39;4&#39;,&#39;5&#39;,&#39;6&#39;},
                        {&#39;7&#39;,&#39;8&#39;,&#39;9&#39;},
                        {&#39;*&#39;,&#39;0&#39;,&#39;#&#39;}};
   printf(&quot;Count for numbers of length %d: %d\n&quot;, 1, getCount(keypad, 1));
   printf(&quot;Count for numbers of length %d: %d\n&quot;, 2, getCount(keypad, 2));
   printf(&quot;Count for numbers of length %d: %d\n&quot;, 3, getCount(keypad, 3));
   printf(&quot;Count for numbers of length %d: %d\n&quot;, 4, getCount(keypad, 4));
   printf(&quot;Count for numbers of length %d: %d\n&quot;, 5, getCount(keypad, 5));

   return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> Count for numbers of length 1: 10
Count for numbers of length 2: 36
Count for numbers of length 3: 138
Count for numbers of length 4: 532
Count for numbers of length 5: 2062
 </code></pre>
<p><strong>Dynamic Programming</strong><br /> There are many repeated traversal on smaller paths (traversal for smaller N) to find all possible longer paths (traversal for bigger N). See following two diagrams for example. In this traversal, for N = 4 from two starting positions (buttons ‘4’ and ‘8’), we can see there are few repeated traversals for N = 2 (e.g. 4 -&gt; 1, 6 -&gt; 3, 8 -&gt; 9, 8 -&gt; 7 etc).</p>
<p><a href="http://d2hc1qfcrygj4j.cloudfront.net//wp-content/uploads/mobile2.png"><img src="media/file32.png" alt="mobile2" /></a></p>
<p><a href="http://d2hc1qfcrygj4j.cloudfront.net//wp-content/uploads/mobile3.png"><img src="media/file33.png" alt="mobile3" /></a></p>
<p>Since the problem has both properties: <a href="http://www.geeksforgeeks.org/dynamic-programming-set-2-optimal-substructure-property/">Optimal Substructure</a> and <a href="http://www.geeksforgeeks.org/dynamic-programming-set-1/">Overlapping Subproblems</a>, it can be efficiently solved using dynamic programming.</p>
<p>Following is C program for dynamic programming implementation.</p>
<pre><code> 
// A Dynamic Programming based C program to count number of
// possible numbers of given length
#include &lt;stdio.h&gt;

// Return count of all possible numbers of length n
// in a given numeric keyboard
int getCount(char keypad[][3], int n)
{
    if(keypad == NULL || n &lt;= 0)
        return 0;
    if(n == 1)
        return 10;

    // left, up, right, down move from current location
    int row[] = {0, 0, -1, 0, 1};
    int col[] = {0, -1, 0, 1, 0};

    // taking n+1 for simplicity - count[i][j] will store
    // number count starting with digit i and length j
    int count[10][n+1];
    int i=0, j=0, k=0, move=0, ro=0, co=0, num = 0;
    int nextNum=0, totalCount = 0;

    // count numbers starting with digit i and of lengths 0 and 1
    for (i=0; i&lt;=9; i++)
    {
        count[i][0] = 0;
        count[i][1] = 1;
    }

    // Bottom up - Get number count of length 2, 3, 4, ... , n
    for (k=2; k&lt;=n; k++)
    {
        for (i=0; i&lt;4; i++)  // Loop on keypad row
        {
            for (j=0; j&lt;3; j++)   // Loop on keypad column
            {
                // Process for 0 to 9 digits
                if (keypad[i][j] != &#39;*&#39; &amp;&amp; keypad[i][j] != &#39;#&#39;)
                {
                    // Here we are counting the numbers starting with
                    // digit keypad[i][j] and of length k keypad[i][j]
                    // will become 1st digit, and we need to look for
                    // (k-1) more digits
                    num = keypad[i][j] - &#39;0&#39;;
                    count[num][k] = 0;

                    // move left, up, right, down from current location
                    // and if new location is valid, then get number
                    // count of length (k-1) from that new digit and
                    // add in count we found so far
                    for (move=0; move&lt;5; move++)
                    {
                        ro = i + row[move];
                        co = j + col[move];
                        if (ro &gt;= 0 &amp;&amp; ro &lt;= 3 &amp;&amp; co &gt;=0 &amp;&amp; co &lt;= 2 &amp;&amp;
                           keypad[ro][co] != &#39;*&#39; &amp;&amp; keypad[ro][co] != &#39;#&#39;)
                        {
                            nextNum = keypad[ro][co] - &#39;0&#39;;
                            count[num][k] += count[nextNum][k-1];
                        }
                    }
                }
            }
        }
    }

    // Get count of all possible numbers of length &quot;n&quot; starting
    // with digit 0, 1, 2, ..., 9
    totalCount = 0;
    for (i=0; i&lt;=9; i++)
        totalCount += count[i][n];
    return totalCount;
}

// Driver program to test above function
int main(int argc, char *argv[])
{
   char keypad[4][3] = {{&#39;1&#39;,&#39;2&#39;,&#39;3&#39;},
                        {&#39;4&#39;,&#39;5&#39;,&#39;6&#39;},
                        {&#39;7&#39;,&#39;8&#39;,&#39;9&#39;},
                        {&#39;*&#39;,&#39;0&#39;,&#39;#&#39;}};
   printf(&quot;Count for numbers of length %d: %d\n&quot;, 1, getCount(keypad, 1));
   printf(&quot;Count for numbers of length %d: %d\n&quot;, 2, getCount(keypad, 2));
   printf(&quot;Count for numbers of length %d: %d\n&quot;, 3, getCount(keypad, 3));
   printf(&quot;Count for numbers of length %d: %d\n&quot;, 4, getCount(keypad, 4));
   printf(&quot;Count for numbers of length %d: %d\n&quot;, 5, getCount(keypad, 5));

   return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> Count for numbers of length 1: 10
Count for numbers of length 2: 36
Count for numbers of length 3: 138
Count for numbers of length 4: 532
Count for numbers of length 5: 2062 </code></pre>
<p><strong>A Space Optimized Solution:</strong><br /> The above dynamic programming approach also runs in O(n) time and requires O(n) auxiliary space, as only one for loop runs n times, other for loops runs for constant time. We can see that nth iteration needs data from (n-1)th iteration only, so we need not keep the data from older iterations. We can have a space efficient dynamic programming approach with just two arrays of size 10. Thanks to Nik for suggesting this solution.</p>
<pre><code> 
// A Space Optimized C program to count number of possible numbers
// of given length
#include &lt;stdio.h&gt;

// Return count of all possible numbers of length n
// in a given numeric keyboard
int getCount(char keypad[][3], int n)
{
    if(keypad == NULL || n &lt;= 0)
        return 0;
    if(n == 1)
        return 10;

    // odd[i], even[i] arrays represent count of numbers starting
    // with digit i for any length j
    int odd[10], even[10];
    int i = 0, j = 0, useOdd = 0, totalCount = 0;

    for (i=0; i&lt;=9; i++)
        odd[i] = 1;  // for j = 1

    for (j=2; j&lt;=n; j++) // Bottom Up calculation from j = 2 to n
    {
        useOdd = 1 - useOdd;

        // Here we are explicitly writing lines for each number 0
        // to 9. But it can always be written as DFS on 4X3 grid
        // using row, column array valid moves
        if(useOdd == 1)
        {
            even[0] = odd[0] + odd[8];
            even[1] = odd[1] + odd[2] + odd[4];
            even[2] = odd[2] + odd[1] + odd[3] + odd[5];
            even[3] = odd[3] + odd[2] + odd[6];
            even[4] = odd[4] + odd[1] + odd[5] + odd[7];
            even[5] = odd[5] + odd[2] + odd[4] + odd[8] + odd[6];
            even[6] = odd[6] + odd[3] + odd[5] + odd[9];
            even[7] = odd[7] + odd[4] + odd[8];
            even[8] = odd[8] + odd[0] + odd[5] + odd[7] + odd[9];
            even[9] = odd[9] + odd[6] + odd[8];
        }
        else
        {
            odd[0] = even[0] + even[8];
            odd[1] = even[1] + even[2] + even[4];
            odd[2] = even[2] + even[1] + even[3] + even[5];
            odd[3] = even[3] + even[2] + even[6];
            odd[4] = even[4] + even[1] + even[5] + even[7];
            odd[5] = even[5] + even[2] + even[4] + even[8] + even[6];
            odd[6] = even[6] + even[3] + even[5] + even[9];
            odd[7] = even[7] + even[4] + even[8];
            odd[8] = even[8] + even[0] + even[5] + even[7] + even[9];
            odd[9] = even[9] + even[6] + even[8];
        }
    }

    // Get count of all possible numbers of length &quot;n&quot; starting
    // with digit 0, 1, 2, ..., 9
    totalCount = 0;
    if(useOdd == 1)
    {
        for (i=0; i&lt;=9; i++)
            totalCount += even[i];
    }
    else
    {
        for (i=0; i&lt;=9; i++)
            totalCount += odd[i];
    }
    return totalCount;
}

// Driver program to test above function
int main()
{
    char keypad[4][3] = {{&#39;1&#39;,&#39;2&#39;,&#39;3&#39;},
        {&#39;4&#39;,&#39;5&#39;,&#39;6&#39;},
        {&#39;7&#39;,&#39;8&#39;,&#39;9&#39;},
        {&#39;*&#39;,&#39;0&#39;,&#39;#&#39;}
    };
    printf(&quot;Count for numbers of length %d: %d\n&quot;, 1, getCount(keypad, 1));
    printf(&quot;Count for numbers of length %d: %d\n&quot;, 2, getCount(keypad, 2));
    printf(&quot;Count for numbers of length %d: %d\n&quot;, 3, getCount(keypad, 3));
    printf(&quot;Count for numbers of length %d: %d\n&quot;, 4, getCount(keypad, 4));
    printf(&quot;Count for numbers of length %d: %d\n&quot;, 5, getCount(keypad, 5));

    return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> Count for numbers of length 1: 10
Count for numbers of length 2: 36
Count for numbers of length 3: 138
Count for numbers of length 4: 532
Count for numbers of length 5: 2062 </code></pre>
<p>This article is contributed by <strong>Anurag Singh</strong>. Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<p><br /></p>
<div id="source-51" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/mobile-numeric-keypad-problem/" class="uri">http://www.geeksforgeeks.org/mobile-numeric-keypad-problem/</a></p>
<p><span>Category: <a href="http://www.geeksforgeeks.org/category/c-programs/">Misc</a></span> <span>Tags: <a href="http://www.geeksforgeeks.org/tag/dynamic-programming/">Dynamic Programming</a>, <a href="http://www.geeksforgeeks.org/tag/matrix/">Matrix</a></span></p>
<p><br /></p>
<p>Post navigation</p>
<p><span class="nav-previous"><a href="http://www.geeksforgeeks.org/comparison-autoboxed-integer-objects-java/"><span class="meta-nav">←</span> Comparison of Autoboxed Integer objects in Java</a></span> <span class="nav-next"><a href="http://www.geeksforgeeks.org/arista-networks-interview-set-3/">Arista Networks Interview | Set 3 <span class="meta-nav">→</span></a></span></p>
<p>Writing code in comment? Please use <a href="http://code.geeksforgeeks.org/">code.geeksforgeeks.org</a>, generate link and share the link here.</p>
</div>
</div>
</body>
</html>


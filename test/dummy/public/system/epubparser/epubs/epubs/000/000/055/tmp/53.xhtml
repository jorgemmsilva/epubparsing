<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Count all possible walks from a source to a destination with exactly k edges</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="count-all-possible-walks-from-a-source-to-a-destination-with-exactly-k-edges" class="section level1">
<h1>Count all possible walks from a source to a destination with exactly k edges</h1>
<p>Given a directed graph and two vertices ‘u’ and ‘v’ in it, count all possible walks from ‘u’ to ‘v’ with exactly k edges on the walk. <span id="more-130464"></span></p>
<p>The graph is given as <a href="http://www.geeksforgeeks.org/graph-and-its-representations/">adjacency matrix representation</a> where value of graph[i][j] as 1 indicates that there is an edge from vertex i to vertex j and a value 0 indicates no edge from i to j.</p>
<p>For example consider the following graph. Let source ‘u’ be vertex 0, destination ‘v’ be 3 and k be 2. The output should be 2 as there are two walk from 0 to 3 with exactly 2 edges. The walks are {0, 2, 3} and {0, 1, 3}</p>
<p><a href="http://d2hc1qfcrygj4j.cloudfront.net//wp-content/uploads/graph1.png"><img src="media/file29.png" alt="graph" /></a></p>
<p><strong>We strongly recommend to minimize the browser and try this yourself first.</strong></p>
<p>A <strong>simple solution</strong> is to start from u, go to all adjacent vertices and recur for adjacent vertices with k as k-1, source as adjacent vertex and destination as v. Following is C++ implementation of this simple solution.</p>
<pre><code> 
// C++ program to count walks from u to v with exactly k edges
#include &lt;iostream&gt;
using namespace std;

// Number of vertices in the graph
#define V 4

// A naive recursive function to count walks from u to v with k edges
int countwalks(int graph[][V], int u, int v, int k)
{
   // Base cases
   if (k == 0 &amp;&amp; u == v)      return 1;
   if (k == 1 &amp;&amp; graph[u][v]) return 1;
   if (k &lt;= 0)                return 0;

   // Initialize result
   int count = 0;

   // Go to all adjacents of u and recur
   for (int i = 0; i &lt; V; i++)
       if (graph[u][i])  // Check if is adjacent of u
           count += countwalks(graph, i, v, k-1);

   return count;
}

// driver program to test above function
int main()
{
    /* Let us create the graph shown in above diagram*/
     int graph[V][V] = { {0, 1, 1, 1},
                        {0, 0, 0, 1},
                        {0, 0, 0, 1},
                        {0, 0, 0, 0}
                      };
    int u = 0, v = 3, k = 2;
    cout &lt;&lt; countwalks(graph, u, v, k);
    return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> 2 </code></pre>
<p>The worst case time complexity of the above function is O(V<sup>k</sup>) where V is the number of vertices in the given graph. We can simply analyze the time complexity by drawing recursion tree. The worst occurs for a complete graph. In worst case, every internal node of recursion tree would have exactly n children.<br /> We can optimize the above solution using <strong><a href="http://www.geeksforgeeks.org/dynamic-programming-set-1/">Dynamic Programming</a></strong>. The idea is to build a 3D table where first dimension is source, second dimension is destination, third dimension is number of edges from source to destination, and the value is count of walks. Like other <a href="http://www.geeksforgeeks.org/tag/dynamic-programming/">Dynamic Programming problems</a>, we fill the 3D table in bottom up manner.</p>
<pre><code> 
// C++ program to count walks from u to v with exactly k edges
#include &lt;iostream&gt;
using namespace std;

// Number of vertices in the graph
#define V 4

// A Dynamic programming based function to count walks from u
// to v with k edges
int countwalks(int graph[][V], int u, int v, int k)
{
    // Table to be filled up using DP. The value count[i][j][e] will
    // store count of possible walks from i to j with exactly k edges
    int count[V][V][k+1];

    // Loop for number of edges from 0 to k
    for (int e = 0; e &lt;= k; e++)
    {
        for (int i = 0; i &lt; V; i++)  // for source
        {
            for (int j = 0; j &lt; V; j++) // for destination
            {
                // initialize value
                count[i][j][e] = 0;

                // from base cases
                if (e == 0 &amp;&amp; i == j)
                    count[i][j][e] = 1;
                if (e == 1 &amp;&amp; graph[i][j])
                    count[i][j][e] = 1;

                // go to adjacent only when number of edges is more than 1
                if (e &gt; 1)
                {
                    for (int a = 0; a &lt; V; a++) // adjacent of source i
                        if (graph[i][a])
                            count[i][j][e] += count[a][j][e-1];
                }
           }
        }
    }
    return count[u][v][k];
}

// driver program to test above function
int main()
{
    /* Let us create the graph shown in above diagram*/
     int graph[V][V] = { {0, 1, 1, 1},
                        {0, 0, 0, 1},
                        {0, 0, 0, 1},
                        {0, 0, 0, 0}
                      };
    int u = 0, v = 3, k = 2;
    cout &lt;&lt; countwalks(graph, u, v, k);
    return 0;
} </code></pre>
<p>Output:</p>
<pre><code> 2 </code></pre>
<p>Time complexity of the above DP based solution is O(V<sup>3</sup>K) which is much better than the naive solution.</p>
<p>We can also use <strong><a href="http://www.geeksforgeeks.org/divide-and-conquer-set-1-find-closest-pair-of-points/">Divide and Conquer</a></strong> to solve the above problem in O(V<sup>3</sup>Logk) time. The count of walks of length k from u to v is the [u][v]’th entry in (graph[V][V])<sup>k</sup>. We can calculate power of by doing O(Logk) multiplication by using the <a href="http://www.geeksforgeeks.org/write-a-c-program-to-calculate-powxn/">divide and conquer technique to calculate power</a>. A multiplication between two matrices of size V x V takes O(V<sup>3</sup>) time. Therefore overall time complexity of this method is O(V<sup>3</sup>Logk).</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<p><br /></p>
<div id="source-49" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/count-possible-paths-source-destination-exactly-k-edges/" class="uri">http://www.geeksforgeeks.org/count-possible-paths-source-destination-exactly-k-edges/</a></p>
<p><span>Category: <a href="http://www.geeksforgeeks.org/category/graph/">Graph</a></span> <span>Tags: <a href="http://www.geeksforgeeks.org/tag/dynamic-programming/">Dynamic Programming</a></span></p>
<p><br /></p>
<p>Post navigation</p>
<p><span class="nav-previous"><a href="http://www.geeksforgeeks.org/amazon-interview-set-100-campus/"><span class="meta-nav">←</span> Amazon Interview | Set 100 (On-Campus)</a></span> <span class="nav-next"><a href="http://www.geeksforgeeks.org/problem-binary-search-implementations/">A Problem in Many Binary Search Implementations <span class="meta-nav">→</span></a></span></p>
<p>Writing code in comment? Please use <a href="http://code.geeksforgeeks.org/">code.geeksforgeeks.org</a>, generate link and share the link here.</p>
</div>
</div>
</body>
</html>


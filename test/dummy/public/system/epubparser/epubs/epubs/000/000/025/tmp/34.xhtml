<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Dynamic Programming | Set 24 (Optimal Binary Search Tree)</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="dynamic-programming-set-24-optimal-binary-search-tree" class="section level1">
<h1>Dynamic Programming | Set 24 (Optimal Binary Search Tree)</h1>
<p>Given a sorted array <em>keys[0.. n-1]</em> of search keys and an array <em>freq[0.. n-1]</em> of frequency counts, where <em>freq[i]</em> is the number of searches to <em>keys[i]</em>. Construct a binary search tree of all keys such that the total cost of all the searches is as small as possible.<span id="more-28316"></span></p>
<p>Let us first define the cost of a BST. The cost of a BST node is level of that node multiplied by its frequency. Level of root is 1.</p>
<pre><code> 
Example 1
Input:  keys[] = {10, 12}, freq[] = {34, 50}
There can be following two possible BSTs 
        10                       12
          \                     / 
           12                 10
          I                     II
Frequency of searches of 10 and 12 are 34 and 50 respectively.
The cost of tree I is 34*1 + 50*2 = 134
The cost of tree II is 50*1 + 34*2 = 118 

Example 2
Input:  keys[] = {10, 12, 20}, freq[] = {34, 8, 50}
There can be following possible BSTs
    10                12                 20         10              20
      \             /    \              /             \            /
      12          10     20           12               20         10  
        \                            /                 /           \
         20                        10                12             12  
     I               II             III             IV             V
Among all possible BSTs, cost of the fifth BST is minimum.  
Cost of the fifth BST is 1*50 + 2*34 + 3*8 = 142
 </code></pre>
<p><strong>1) Optimal Substructure:</strong><br /> The optimal cost for freq[i..j] can be recursively calculated using following formula.<br /> <a href="http://d2hc1qfcrygj4j.cloudfront.net//wp-content/uploads/optcost.png"><img src="media/file15.png" alt="optcost" /></a></p>
<p>We need to calculate <em><strong>optCost(0, n-1)</strong></em> to find the result.</p>
<p>The idea of above formula is simple, we one by one try all nodes as root (r varies from i to j in second term). When we make <em>rth</em> node as root, we recursively calculate optimal cost from i to r-1 and r+1 to j.<br /> We add sum of frequencies from i to j (see first term in the above formula), this is added because every search will go through root and one comparison will be done for every search.</p>
<p><strong>2) Overlapping Subproblems</strong><br /> Following is recursive implementation that simply follows the recursive structure mentioned above.</p>
<pre><code> 
// A naive recursive implementation of optimal binary search tree problem
#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

// A utility function to get sum of array elements freq[i] to freq[j]
int sum(int freq[], int i, int j);

// A recursive function to calculate cost of optimal binary search tree
int optCost(int freq[], int i, int j)
{
   // Base cases
   if (j &lt; i)      // If there are no elements in this subarray
     return 0;
   if (j == i)     // If there is one element in this subarray
     return freq[i];

   // Get sum of freq[i], freq[i+1], ... freq[j]
   int fsum = sum(freq, i, j);

   // Initialize minimum value
   int min = INT_MAX;

   // One by one consider all elements as root and recursively find cost
   // of the BST, compare the cost with min and update min if needed
   for (int r = i; r &lt;= j; ++r)
   {
       int cost = optCost(freq, i, r-1) + optCost(freq, r+1, j);
       if (cost &lt; min)
          min = cost;
   }

   // Return minimum value
   return min + fsum;
}

// The main function that calculates minimum cost of a Binary Search Tree.
// It mainly uses optCost() to find the optimal cost.
int optimalSearchTree(int keys[], int freq[], int n)
{
     // Here array keys[] is assumed to be sorted in increasing order.
     // If keys[] is not sorted, then add code to sort keys, and rearrange
     // freq[] accordingly.
     return optCost(freq, 0, n-1);
}

// A utility function to get sum of array elements freq[i] to freq[j]
int sum(int freq[], int i, int j)
{
    int s = 0;
    for (int k = i; k &lt;=j; k++)
       s += freq[k];
    return s;
}

// Driver program to test above functions
int main()
{
    int keys[] = {10, 12, 20};
    int freq[] = {34, 8, 50};
    int n = sizeof(keys)/sizeof(keys[0]);
    printf(&quot;Cost of Optimal BST is %d &quot;, optimalSearchTree(keys, freq, n));
    return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> Cost of Optimal BST is 142 </code></pre>
<p>Time complexity of the above naive recursive approach is exponential. It should be noted that the above function computes the same subproblems again and again. We can see many subproblems being repeated in the following recursion tree for freq[1..4].</p>
<p><a href="http://d2hc1qfcrygj4j.cloudfront.net//wp-content/uploads/MatrixChain1.jpg"><img src="media/file7.jpg" title="MatrixChain" /></a></p>
<p>Since same suproblems are called again, this problem has Overlapping Subprolems property. So optimal BST problem has both properties (see <a href="http://www.geeksforgeeks.org/archives/12635">this</a>and <a href="http://www.geeksforgeeks.org/archives/12819">this</a>) of a dynamic programming problem. Like other typical <a href="http://www.geeksforgeeks.org/archives/tag/dynamic-programming">Dynamic Programming(DP) problems,</a> recomputations of same subproblems can be avoided by constructing a temporary array cost[][] in bottom up manner.</p>
<p><strong>Dynamic Programming Solution</strong><br /> Following is C/C++ implementation for optimal BST problem using Dynamic Programming. We use an auxiliary array cost[n][n] to store the solutions of subproblems. cost[0][n-1] will hold the final result. The challenge in implementation is, all diagonal values must be filled first, then the values which lie on the line just above the diagonal. In other words, we must first fill all cost[i][i] values, then all cost[i][i+1] values, then all cost[i][i+2] values. So how to fill the 2D array in such manner&gt; The idea used in the implementation is same as <a href="http://www.geeksforgeeks.org/archives/15553">Matrix Chain Multiplication problem</a>, we use a variable ‘L’ for chain length and increment ‘L’, one by one. We calculate column number ‘j’ using the values of ‘i’ and ‘L’.</p>
<pre><code> 
// Dynamic Programming code for Optimal Binary Search Tree Problem
#include &lt;stdio.h&gt;
#include &lt;limits.h&gt;

// A utility function to get sum of array elements freq[i] to freq[j]
int sum(int freq[], int i, int j);

/* A Dynamic Programming based function that calculates minimum cost of
   a Binary Search Tree. */
int optimalSearchTree(int keys[], int freq[], int n)
{
    /* Create an auxiliary 2D matrix to store results of subproblems */
    int cost[n][n];

    /* cost[i][j] = Optimal cost of binary search tree that can be
       formed from keys[i] to keys[j].
       cost[0][n-1] will store the resultant cost */

    // For a single key, cost is equal to frequency of the key
    for (int i = 0; i &lt; n; i++)
        cost[i][i] = freq[i];

    // Now we need to consider chains of length 2, 3, ... .
    // L is chain length.
    for (int L=2; L&lt;=n; L++)
    {
        // i is row number in cost[][]
        for (int i=0; i&lt;=n-L+1; i++)
        {
            // Get column number j from row number i and chain length L
            int j = i+L-1;
            cost[i][j] = INT_MAX;

            // Try making all keys in interval keys[i..j] as root
            for (int r=i; r&lt;=j; r++)
            {
               // c = cost when keys[r] becomes root of this subtree
               int c = ((r &gt; i)? cost[i][r-1]:0) + 
                       ((r &lt; j)? cost[r+1][j]:0) + 
                       sum(freq, i, j);
               if (c &lt; cost[i][j])
                  cost[i][j] = c;
            }
        }
    }
    return cost[0][n-1];
}

// A utility function to get sum of array elements freq[i] to freq[j]
int sum(int freq[], int i, int j)
{
    int s = 0;
    for (int k = i; k &lt;=j; k++)
       s += freq[k];
    return s;
}

// Driver program to test above functions
int main()
{
    int keys[] = {10, 12, 20};
    int freq[] = {34, 8, 50};
    int n = sizeof(keys)/sizeof(keys[0]);
    printf(&quot;Cost of Optimal BST is %d &quot;, optimalSearchTree(keys, freq, n));
    return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> Cost of Optimal BST is 142 </code></pre>
<p><strong>Notes</strong><br /> <strong>1)</strong> The time complexity of the above solution is O(n^4). The time complexity can be easily reduced to O(n^3) by pre-calculating sum of frequencies instead of calling sum() again and again.</p>
<p><strong>2)</strong> In the above solutions, we have computed optimal cost only. The solutions can be easily modified to store the structure of BSTs also. We can create another auxiliary array of size n to store the structure of tree. All we need to do is, store the chosen ‘r’ in the innermost loop.</p>
<p><br /> Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<p><br /></p>
<div id="source-30" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/dynamic-programming-set-24-optimal-binary-search-tree/" class="uri">http://www.geeksforgeeks.org/dynamic-programming-set-24-optimal-binary-search-tree/</a></p>
<p><span>Category: <a href="http://www.geeksforgeeks.org/category/c-programs/">Misc</a></span> <span>Tags: <a href="http://www.geeksforgeeks.org/tag/dynamic-programming/">Dynamic Programming</a></span></p>
<p><br /></p>
<p>Post navigation</p>
<p><span class="nav-previous"><a href="http://www.geeksforgeeks.org/strand-life-sciences-interview-set-1/"><span class="meta-nav">←</span> Strand Life Sciences Interview | Set 1</a></span> <span class="nav-next"><a href="http://www.geeksforgeeks.org/facebook-interview-set-1/">Facebook Interview | Set 1 <span class="meta-nav">→</span></a></span></p>
<p>Writing code in comment? Please use <a href="http://code.geeksforgeeks.org/">code.geeksforgeeks.org</a>, generate link and share the link here.</p>
</div>
</div>
</body>
</html>


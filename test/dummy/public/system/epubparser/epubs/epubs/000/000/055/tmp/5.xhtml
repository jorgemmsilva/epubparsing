<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Largest Sum Contiguous Subarray</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="largest-sum-contiguous-subarray" class="section level1">
<h1>Largest Sum Contiguous Subarray</h1>
<p>Write an efficient C program to find the sum of contiguous subarray within a one-dimensional array of numbers which has the largest sum. <span id="more-576"></span></p>
<p><strong>Kadane’s Algorithm:</strong></p>
<pre><code> 
Initialize:
    max_so_far = 0
    max_ending_here = 0

Loop for each element of the array
  (a) max_ending_here = max_ending_here + a[i]
  (b) if(max_ending_here 
Explanation:

Simple idea of the Kadane&#39;s algorithm is to look for all positive contiguous segments of the array (max_ending_here is used for this).  And keep track of maximum sum contiguous segment  among all positive segments (max_so_far is used for this).  Each time we get a positive sum compare it with max_so_far and update max_so_far if it is greater than max_so_far
 
    Lets take the example:
    {-2, -3, 4, -1, -2, 1, 5, -3}

    max_so_far = max_ending_here = 0

    for i=0,  a[0] =  -2
    max_ending_here = max_ending_here + (-2)
    Set max_ending_here = 0 because max_ending_here 
Program:
 
    #include&lt;stdio.h&gt;
    int maxSubArraySum(int a[], int size)
    {
       int max_so_far = 0, max_ending_here = 0;
       int i;
       for(i = 0; i &lt; size; i++)
       {
         max_ending_here = max_ending_here + a[i];
         if (max_ending_here &lt; 0)
            max_ending_here = 0;
         if (max_so_far &lt; max_ending_here)
            max_so_far = max_ending_here;
        }
        return max_so_far;
    } 

    /*Driver program to test maxSubArraySum*/
    int main()
    {
       int a[] = {-2, -3, 4, -1, -2, 1, 5, -3};
       int n = sizeof(a)/sizeof(a[0]);
       int max_sum = maxSubArraySum(a, n);
       printf(&quot;Maximum contiguous sum is %d\n&quot;, max_sum);
       getchar();
       return 0;
    }
 </code></pre>
<p><strong>Notes:</strong><br /> Algorithm doesn't work for all negative numbers. It simply returns 0 if all numbers are negative. For handling this we can add an extra phase before actual implementation. The phase will look if all numbers are negative, if they are it will return maximum of them (or smallest in terms of absolute value). There may be other ways to handle it though.</p>
<p>Above program can be optimized further, if we compare max_so_far with max_ending_here only if max_ending_here is greater than 0.</p>
<pre><code> 
    int maxSubArraySum(int a[], int size)
    {
       int max_so_far = 0, max_ending_here = 0;
       int i;
       for(i = 0; i &lt; size; i++)
       {
         max_ending_here = max_ending_here + a[i];
         if(max_ending_here &lt; 0)
             max_ending_here = 0;

         /* Do not compare for all elements. Compare only   
            when  max_ending_here &gt; 0 */
         else if (max_so_far &lt; max_ending_here)
             max_so_far = max_ending_here;
       }
       return max_so_far;
    }
 </code></pre>
<p><strong>Time Complexity:</strong> O(n)<br /> <strong>Algorithmic Paradigm:</strong> Dynamic Programming</p>
<p>Following is another simple implementation suggested by <strong>Mohit Kumar</strong>. The implementation handles the case when all numbers in array are negative.</p>
<pre><code> 
#include&lt;stdio.h&gt;

int max(int x, int y)
{ return (y &gt; x)? y : x; }

int maxSubArraySum(int a[], int size)
{
   int max_so_far = a[0], i;
   int curr_max = a[0];

   for (i = 1; i &lt; size; i++)
   {
        curr_max = max(a[i], curr_max+a[i]);
        max_so_far = max(max_so_far, curr_max);
   }
   return max_so_far;
}

/* Driver program to test maxSubArraySum */
int main()
{
   int a[] =  {-2, -3, 4, -1, -2, 1, 5, -3};
   int n = sizeof(a)/sizeof(a[0]);
   int max_sum = maxSubArraySum(a, n);
   printf(&quot;Maximum contiguous sum is %d\n&quot;, max_sum);
   return 0;
}
 </code></pre>
<p>Now try below question<br /> Given an array of integers (possibly some of the elements negative), write a C program to find out the *maximum product* possible by adding 'n' consecutive integers in the array, n<br /> <strong>References:</strong><br /> <a href="http://en.wikipedia.org/wiki/Kadane%27s_Algorithm">http://en.wikipedia.org/wiki/Kadane%27s_Algorithm</a></p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<p><br /></p>
<div id="source" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/largest-sum-contiguous-subarray/" class="uri">http://www.geeksforgeeks.org/largest-sum-contiguous-subarray/</a></p>
<p><span>Category: <a href="http://www.geeksforgeeks.org/category/c-arrays/">Arrays</a></span> <span>Tags: <a href="http://www.geeksforgeeks.org/tag/dynamic-programming/">Dynamic Programming</a></span></p>
<p><br /></p>
<p>Post navigation</p>
<p><span class="nav-previous"><a href="http://www.geeksforgeeks.org/find-the-number-occurring-odd-number-of-times/"><span class="meta-nav">←</span> Find the Number Occurring Odd Number of Times</a></span> <span class="nav-next"><a href="http://www.geeksforgeeks.org/implement-your-own-sizeof/">Implement Your Own sizeof <span class="meta-nav">→</span></a></span></p>
<p>Writing code in comment? Please use <a href="http://code.geeksforgeeks.org/">code.geeksforgeeks.org</a>, generate link and share the link here.</p>
</div>
</div>
</body>
</html>


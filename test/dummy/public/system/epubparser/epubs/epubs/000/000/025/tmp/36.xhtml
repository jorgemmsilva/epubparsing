<?xml version="1.0" encoding="UTF-8"?>
<!DOCTYPE html PUBLIC "-//W3C//DTD XHTML 1.1//EN" "http://www.w3.org/TR/xhtml11/DTD/xhtml11.dtd">
<html xmlns="http://www.w3.org/1999/xhtml">
<head>
  <meta http-equiv="Content-Type" content="text/html; charset=utf-8" />
  <meta http-equiv="Content-Style-Type" content="text/css" />
  <meta name="generator" content="pandoc" />
  <title>Dynamic Programming | Set 26 (Largest Independent Set Problem)</title>
  <link rel="stylesheet" type="text/css" href="stylesheet.css" />
</head>
<body>
<div id="dynamic-programming-set-26-largest-independent-set-problem" class="section level1">
<h1>Dynamic Programming | Set 26 (Largest Independent Set Problem)</h1>
<p>Given a Binary Tree, find size of the <strong>L</strong>argest <strong>I</strong>ndependent <strong>S</strong>et(LIS) in it. A subset of all tree nodes is an independent set if there is no edge between any two nodes of the subset.<br /> For example, consider the following binary tree. The largest independent set(LIS) is {10, 40, 60, 70, 80} and size of the LIS is 5.<span id="more-114526"></span></p>
<p><a href="http://d2hc1qfcrygj4j.cloudfront.net//wp-content/uploads/LargestIndependentSet.png"><img src="media/file16.png" title="LargestIndependentSet" /></a></p>
<p>A Dynamic Programming solution solves a given problem using solutions of subproblems in bottom up manner. Can the given problem be solved using solutions to subproblems? If yes, then what are the subproblems? Can we find largest independent set size (LISS) for a node X if we know LISS for all descendants of X? If a node is considered as part of LIS, then its children cannot be part of LIS, but its grandchildren can be. Following is optimal substructure property.</p>
<p><strong>1) Optimal Substructure:</strong><br /> Let LISS(X) indicates size of largest independent set of a tree with root X.</p>
<pre><code> 
     LISS(X) = MAX { (1 + sum of LISS for all grandchildren of X),
                     (sum of LISS for all children of X) }
 </code></pre>
<p>The idea is simple, there are two possibilities for every node X, either X is a member of the set or not a member. If X is a member, then the value of LISS(X) is 1 plus LISS of all grandchildren. If X is not a member, then the value is sum of LISS of all children.</p>
<p><strong>2) Overlapping Subproblems</strong><br /> Following is recursive implementation that simply follows the recursive structure mentioned above.</p>
<pre><code> 
// A naive recursive implementation of Largest Independent Set problem
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// A utility function to find max of two integers
int max(int x, int y) { return (x &gt; y)? x: y; }

/* A binary tree node has data, pointer to left child and a pointer to 
   right child */
struct node
{
    int data;
    struct node *left, *right;
};

// The function returns size of the largest independent set in a given 
// binary tree
int LISS(struct node *root)
{
    if (root == NULL)
       return 0;

    // Caculate size excluding the current node
    int size_excl = LISS(root-&gt;left) + LISS(root-&gt;right);

    // Calculate size including the current node
    int size_incl = 1;
    if (root-&gt;left)
       size_incl += LISS(root-&gt;left-&gt;left) + LISS(root-&gt;left-&gt;right);
    if (root-&gt;right)
       size_incl += LISS(root-&gt;right-&gt;left) + LISS(root-&gt;right-&gt;right);

    // Return the maximum of two sizes
    return max(size_incl, size_excl);
}


// A utility function to create a node
struct node* newNode( int data )
{
    struct node* temp = (struct node *) malloc( sizeof(struct node) );
    temp-&gt;data = data;
    temp-&gt;left = temp-&gt;right = NULL;
    return temp;
}

// Driver program to test above functions
int main()
{
    // Let us construct the tree given in the above diagram
    struct node *root         = newNode(20);
    root-&gt;left                = newNode(8);
    root-&gt;left-&gt;left          = newNode(4);
    root-&gt;left-&gt;right         = newNode(12);
    root-&gt;left-&gt;right-&gt;left   = newNode(10);
    root-&gt;left-&gt;right-&gt;right  = newNode(14);
    root-&gt;right               = newNode(22);
    root-&gt;right-&gt;right        = newNode(25);

    printf (&quot;Size of the Largest Independent Set is %d &quot;, LISS(root));

    return 0;
}
 </code></pre>
<p>Output:</p>
<pre><code> Size of the Largest Independent Set is 5 </code></pre>
<p>Time complexity of the above naive recursive approach is exponential. It should be noted that the above function computes the same subproblems again and again. For example, LISS of node with value 50 is evaluated for node with values 10 and 20 as 50 is grandchild of 10 and child of 20.<br /> Since same suproblems are called again, this problem has Overlapping Subprolems property. So LISS problem has both properties (see <a href="http://www.geeksforgeeks.org/archives/12635">this</a>and <a href="http://www.geeksforgeeks.org/archives/12819">this</a>) of a dynamic programming problem. Like other typical <a href="http://www.geeksforgeeks.org/archives/tag/dynamic-programming">Dynamic Programming(DP) problems,</a> recomputations of same subproblems can be avoided by storing the solutions to subproblems and solving problems in bottom up manner.</p>
<p>Following is C implementation of Dynamic Programming based solution. In the following solution, an additional field ‘liss’ is added to tree nodes. The initial value of ‘liss’ is set as 0 for all nodes. The recursive function LISS() calculates ‘liss’ for a node only if it is not already set.</p>
<pre><code> 
/* Dynamic programming based program for Largest Independent Set problem */
#include &lt;stdio.h&gt;
#include &lt;stdlib.h&gt;

// A utility function to find max of two integers
int max(int x, int y) { return (x &gt; y)? x: y; }

/* A binary tree node has data, pointer to left child and a pointer to 
   right child */
struct node
{
    int data;
    int liss;
    struct node *left, *right;
};

// A memoization function returns size of the largest independent set in
//  a given binary tree
int LISS(struct node *root)
{
    if (root == NULL)
        return 0;

    if (root-&gt;liss)
        return root-&gt;liss;

    if (root-&gt;left == NULL &amp;&amp; root-&gt;right == NULL)
        return (root-&gt;liss = 1);

    // Calculate size excluding the current node
    int liss_excl = LISS(root-&gt;left) + LISS(root-&gt;right);

    // Calculate size including the current node
    int liss_incl = 1;
    if (root-&gt;left)
        liss_incl += LISS(root-&gt;left-&gt;left) + LISS(root-&gt;left-&gt;right);
    if (root-&gt;right)
        liss_incl += LISS(root-&gt;right-&gt;left) + LISS(root-&gt;right-&gt;right);

    // Maximum of two sizes is LISS, store it for future uses.
    root-&gt;liss = max(liss_incl, liss_excl);

    return root-&gt;liss;
}

// A utility function to create a node
struct node* newNode(int data)
{
    struct node* temp = (struct node *) malloc( sizeof(struct node) );
    temp-&gt;data = data;
    temp-&gt;left = temp-&gt;right = NULL;
    temp-&gt;liss = 0;
    return temp;
}

// Driver program to test above functions
int main()
{
    // Let us construct the tree given in the above diagram
    struct node *root         = newNode(20);
    root-&gt;left                = newNode(8);
    root-&gt;left-&gt;left          = newNode(4);
    root-&gt;left-&gt;right         = newNode(12);
    root-&gt;left-&gt;right-&gt;left   = newNode(10);
    root-&gt;left-&gt;right-&gt;right  = newNode(14);
    root-&gt;right               = newNode(22);
    root-&gt;right-&gt;right        = newNode(25);

    printf (&quot;Size of the Largest Independent Set is %d &quot;, LISS(root));

    return 0;
}
 </code></pre>
<p>Output</p>
<pre><code> Size of the Largest Independent Set is 5 </code></pre>
<p>Time Complexity: O(n) where n is the number of nodes in given Binary tree.</p>
<p>Following extensions to above solution can be tried as an exercise.<br /> <strong>1)</strong> Extend the above solution for n-ary tree.</p>
<p><strong>2)</strong> The above solution modifies the given tree structure by adding an additional field ‘liss’ to tree nodes. Extend the solution so that it doesn’t modify the tree structure.</p>
<p><strong>3)</strong> The above solution only returns size of LIS, it doesn’t print elements of LIS. Extend the solution to print all nodes that are part of LIS.</p>
<p>Please write comments if you find anything incorrect, or you want to share more information about the topic discussed above.</p>
<p><br /></p>
<div id="source-32" class="section level3">
<h3>Source</h3>
<p><a href="http://www.geeksforgeeks.org/largest-independent-set-problem/" class="uri">http://www.geeksforgeeks.org/largest-independent-set-problem/</a></p>
</div>
</div>
</body>
</html>

